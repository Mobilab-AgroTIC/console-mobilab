[
    {
        "id": "bd7fdadec2d6549d",
        "type": "subflow",
        "name": "console mobilab",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 40,
                "y": 420,
                "wires": [
                    {
                        "id": "d86793857733f664"
                    },
                    {
                        "id": "ab69ac2d5c597e24"
                    },
                    {
                        "id": "3fd947473024feec"
                    },
                    {
                        "id": "8d50ae7fda2a3a3c"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 200,
                "y": 40,
                "wires": [
                    {
                        "id": "e27efcb5fecdc72c",
                        "port": 0
                    }
                ]
            },
            {
                "x": 2040,
                "y": 220,
                "wires": [
                    {
                        "id": "2ee8e04601530170",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#3FADB5"
    },
    {
        "id": "d86793857733f664",
        "type": "switch",
        "z": "bd7fdadec2d6549d",
        "name": "Autoconstruction",
        "property": "payload.end_device_ids.device_id",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "pilowtech",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "debit",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "irritrace",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "sel",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "senpow",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "watermark",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "sonar",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "waterlow",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "porte",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lancelot",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "bme680",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "furgo",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "temperature",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "davele",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "latex",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 15,
        "x": 290,
        "y": 160,
        "wires": [
            [
                "baa53bbf13aeeb13"
            ],
            [
                "baa53bbf13aeeb13"
            ],
            [
                "baa53bbf13aeeb13"
            ],
            [
                "baa53bbf13aeeb13"
            ],
            [
                "baa53bbf13aeeb13"
            ],
            [
                "baa53bbf13aeeb13"
            ],
            [
                "baa53bbf13aeeb13"
            ],
            [
                "c7e8abbb3fe38f0b"
            ],
            [
                "c15299ef6a8aa811"
            ],
            [
                "e4d451fb2d115299"
            ],
            [
                "375abb38d2950b09"
            ],
            [
                "abd2a74a209347b5"
            ],
            [
                "70bc8f3e6d3dcfbb"
            ],
            [
                "391656f407ad734e"
            ],
            [
                "fe9a13e81e796e07"
            ]
        ]
    },
    {
        "id": "c7e8abbb3fe38f0b",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "waterlow",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": msg.payload.uplink_message.decoded_payload[\"BAT_V\"],\n        \"value\": msg.payload.uplink_message.decoded_payload[\"WATER_LEAK_STATUS\"]\n    };\nmsg.payload=message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 140,
        "wires": [
            [
                "e594f38c2089448b",
                "d35518380c2038d5"
            ]
        ]
    },
    {
        "id": "baa53bbf13aeeb13",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "2 bytes/valeur : Irritrace, pilowtech, Watermark, sonar, debit",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": msg.payload.uplink_message.decoded_payload.bytes[0],\n    \"value\": ((msg.payload.uplink_message.decoded_payload.bytes[1] * 256) + msg.payload.uplink_message.decoded_payload.bytes[2])\n};\n\n// Vérifie si msg.payload.uplink_message.decoded_payload.bytes[3] existe\nif (msg.payload.uplink_message.decoded_payload.bytes[3] !== undefined) {\n    // Si oui, ajoute la deuxième valeur\n    message.value2 = ((msg.payload.uplink_message.decoded_payload.bytes[3] * 256) + msg.payload.uplink_message.decoded_payload.bytes[4]);\n}\n\n// Vérifie si msg.payload.uplink_message.decoded_payload.bytes[3] existe\nif (msg.payload.uplink_message.decoded_payload.bytes[5] !== undefined) {\n    // Si oui, ajoute la deuxième valeur\n    message.value3 = ((msg.payload.uplink_message.decoded_payload.bytes[5] * 256) + msg.payload.uplink_message.decoded_payload.bytes[6]);\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 100,
        "wires": [
            [
                "d35518380c2038d5"
            ]
        ]
    },
    {
        "id": "e4d451fb2d115299",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "lancelot",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n    \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n    \"battery\": msg.payload.uplink_message.decoded_payload.bytes[0],\n};\nmsg.payload=message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 220,
        "wires": [
            [
                "d35518380c2038d5",
                "0a5586cdb658de53"
            ]
        ]
    },
    {
        "id": "d262c36a161c3093",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "1 byte/valeur : ",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n    \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n    \"power\": msg.payload.uplink_message.decoded_payload.bytes[0],\n    \"value\": msg.payload.uplink_message.decoded_payload.bytes[1]\n};\n\n// Vérifie si msg.payload.uplink_message.decoded_payload.bytes[2] existe\nif (msg.payload.uplink_message.decoded_payload.bytes[2] !== undefined) {\n    // Si oui, ajoute la deuxième valeur\n    message.value2 = msg.payload.uplink_message.decoded_payload.bytes[2];\n}\nmsg.payload=message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 60,
        "wires": [
            [
                "d35518380c2038d5"
            ]
        ]
    },
    {
        "id": "e594f38c2089448b",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "Alerte Waterlow",
        "func": "var devicesData = flow.get(\"$parent.waterlow\");\nvar msg2 = msg.payload;\nvar oldValue ;\nvar alerte = \"\";\n\n// Vérifier si l'array existe déjà dans le contexte\nif (!devicesData) {\n  devicesData = []; // Si l'array n'existe pas, initialisez-le avec un array vide\n}\n\n\n// Rechercher l'index de l'élément correspondant au \"capteur 2\" dans l'array\nvar capteurIndex = devicesData.findIndex(function (device) {\n  return device.name === msg2.name;\n});\n\n// Vérifier si l'élément \"capteur 2\" a été trouvé\nif (capteurIndex !== -1) {\n\n    oldValue = devicesData[capteurIndex].state;\n    // Le \"capteur\" existe dans l'array, mettez à jour son état\n    devicesData[capteurIndex].state = msg2.value;\n    \n} else {\n  // Le \"capteur\" n'existe pas dans l'array, donc nous allons le créer\n  var nouveauCapteur = {\n    \"name\": msg2.name,\n    \"state\": msg2.value}\n  ;\n  devicesData.push(nouveauCapteur);\n}\n\n// Fonction de comparaison pour trier par ordre alphabétique des noms\nfunction compareName(a, b) {\n  var nameA = a.name.toLowerCase();\n  var nameB = b.name.toLowerCase();\n  if (nameA < nameB) return -1;\n  if (nameA > nameB) return 1;\n  return 0;\n}\n\n// Trier l'array par ordre alphabétique des noms des capteurs en utilisant la fonction de comparaison\ndevicesData.sort(compareName);\n\n// Enregistrer à nouveau l'array trié dans la variable de contexte \"devicesData\"\nflow.set(\"$parent.waterlow\", devicesData);\n\n// Envoi alerte si l'état a changé\nmsg.telegram={};\n\nif (oldValue != msg.payload.value){\n    oldValue = msg.payload.value;\n    msg.telegram.payload={}\n    msg.telegram.payload.chatId = flow.get(\"$parent.chatId\");\n    msg.telegram.payload.content = \"le \" + msg2.name + \" passe en \" + msg2.value ;\n    msg.telegram.payload.type = \"message\";\n    return msg.telegram;\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 140,
        "wires": [
            [
                "97f3a34543148b88"
            ]
        ]
    },
    {
        "id": "378d1b52bef108b9",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "Alerte Porte",
        "func": "var devicesData = flow.get(\"$parent.porte\");\nvar msg2 = msg.payload;\nvar oldValue;\nvar alerte = \"\";\n\n// Vérifier si l'array existe déjà dans le contexte\nif (!devicesData) {\n  devicesData = []; // Si l'array n'existe pas, initialisez-le avec un array vide\n}\n\n\n// Rechercher l'index de l'élément correspondant au \"capteur 2\" dans l'array\nvar capteurIndex = devicesData.findIndex(function (device) {\n  return device.name === msg2.name;\n});\n\n// Vérifier si l'élément \"capteur 2\" a été trouvé\nif (capteurIndex !== -1) {\n\n  oldValue = devicesData[capteurIndex].state;\n  // Le \"capteur\" existe dans l'array, mettez à jour son état\n  devicesData[capteurIndex].state = msg2.value;\n\n} else {\n  // Le \"capteur\" n'existe pas dans l'array, donc nous allons le créer\n  var nouveauCapteur = {\n    \"name\": msg2.name,\n    \"state\": msg2.value,\n    \"power\": msg2.power\n  }\n    ;\n  devicesData.push(nouveauCapteur);\n}\n\n// Fonction de comparaison pour trier par ordre alphabétique des noms\nfunction compareName(a, b) {\n  var nameA = a.name.toLowerCase();\n  var nameB = b.name.toLowerCase();\n  if (nameA < nameB) return -1;\n  if (nameA > nameB) return 1;\n  return 0;\n}\n\n// Trier l'array par ordre alphabétique des noms des capteurs en utilisant la fonction de comparaison\ndevicesData.sort(compareName);\n\n// Enregistrer à nouveau l'array trié dans la variable de contexte \"devicesData\"\nflow.set(\"$parent.porte\", devicesData);\n\n// Envoi alerte si l'état a changé\nmsg.telegram = {};\n\nif (oldValue != msg.payload.value) {\n  oldValue = msg.payload.value;\n  msg.telegram.payload = {}\n  msg.telegram.payload.chatId = flow.get(\"$parent.chatId\");\n  msg.telegram.payload.content = \"la \" + msg2.name + \" passe en \" + msg2.value;\n  msg.telegram.payload.type = \"message\";\n  return msg.telegram;\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 180,
        "wires": [
            [
                "97f3a34543148b88"
            ]
        ]
    },
    {
        "id": "4e09185f9dae5f10",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "msg",
        "func": "var message_connu = {\n    \"chatId\": msg.payload.chatId,\n    \"content\": \"Bonjour !\\n\\nVoici ce que vous pouvez m'envoyer comme commande :\\n\\n- /waterlow : pour connaître l'état de vos waterlow\\n- /porte : pour vérifier l'état de vos portes\\n- /lancelot : pour actionner vos Lancelot\\n\\nN'hésitez pas à me demander ou bien à appuyer directement sur les mots en bleu! \\n\\n Pour info, votre id :  \" + msg.payload.chatId,\n    \"type\": \"message\"\n}\n\nif (msg.payload.chatId == flow.get(\"$parent.chatId\")) \n{\n    msg.payload = message_connu\n    return msg\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1270,
        "y": 40,
        "wires": [
            [
                "d44931fe0ec84601",
                "73ef40b751c41f01"
            ]
        ]
    },
    {
        "id": "607a2d97902e1510",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "msg",
        "func": "if (msg.payload.chatId== flow.get(\"$parent.chatId\")){\n    \n    //msg.payload={}\n    msg.payload.chatId = msg.payload.chatId;\n\n    // Récupérer l'array \"devicesData\" depuis la variable de contexte\n    var devicesData = flow.get(\"$parent.waterlow\");\n    \n    if (Array.isArray(devicesData)) {\n      // Générer le message avec l'état des capteurs\n      var message = \"État des Waterlows :\\n\";\n    \n      devicesData.forEach(function (device) {\n        message += device.name + \" : \" + device.state + \"\\n\";\n      });\n    \n      msg.payload.content = message;\n      return msg;\n    } \n    \n    else {\n      msg.payload.content = \"Aucun Waterlow trouvé !\";\n    }\n    \n    msg.payload.type = \"message\";\n    return msg\n}\nelse {}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1270,
        "y": 80,
        "wires": [
            [
                "d44931fe0ec84601"
            ]
        ]
    },
    {
        "id": "31c88bf4584eb6aa",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "save msgId",
        "func": "// We store the messageId to be able to edit this reply in the callback query. \ncontext.global.keyboard.messageId = msg.payload.sentMessageId;\n\nreturn [ msg ];\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "8e9f98201941b052",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "msg",
        "func": "if (msg.payload.chatId == flow.get(\"$parent.chatId\")) {\n\n  context.global.keyboard = { messageId: msg.payload.messageId };\n\n\n  var inputArray = flow.get(\"$parent.lancelot\");\n  // Vérifier si l'array existe déjà dans le contexte\n  if (!inputArray) {\n    // Si l'array n'existe pas, initialisez-le avec un array vide\n  }\n  // Initialiser un nouvel array pour stocker les boutons transformés du clavier\n  var keyboardButtons = [];\n\n  // Utiliser forEach pour itérer sur chaque élément du tableau\n  inputArray.forEach(function (item) {\n    // Extraire le nom du bouton (si \"name\" est défini, sinon utiliser une valeur par défaut)\n    var buttonText = item.name || \"no_name\";\n    // Extraire le callback_data du bouton (si \"name\" est défini, sinon utiliser une valeur par défaut)\n    var callbackData = item.name || \"no_name\";\n\n    var button = {\n      text: buttonText,\n      callback_data: callbackData\n    };\n\n    keyboardButtons.push(button);\n  });\n\n  var transformedArray = keyboardButtons.map(function (item) {\n    return [item];\n  });\n\n\n  var transformedObject = {\n    \"inline_keyboard\": transformedArray\n  };\n  var opts = {\n    reply_to_message_id: msg.payload.messageId,\n    reply_markup: JSON.stringify(transformedObject)\n  };\n\n  msg.payload.content = 'Bien reçu ! Quelle martelière dois-je fermer ?';\n  msg.payload.options = opts;\n\n  return [msg];\n}\nelse { };",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 200,
        "wires": [
            [
                "f95598d381025cd5"
            ]
        ]
    },
    {
        "id": "2ee8e04601530170",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "Prepare downlink",
        "func": "return {\n  \"payload\": {\n    \"downlinks\": [{\n      \"f_port\": 15,\n      \"frm_payload\": \"AQ==\", //\"frm_payload\": Buffer.from(bytes).toString('base64'),\n      \"priority\": \"NORMAL\"\n    }]\n  },\n  \"topic\" : \"v3/\"+flow.get(\"$parent.appId\")+\"@ttn/devices/\"+msg.payload.device+\"/down/push\" //\"<ApplicationID>>/devices/\" + dev_id + \"/down\";\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1890,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "f7881f2007e15921",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "envoi",
        "func": "var messageId = context.global.keyboard.Id;\n\nmsg.payload.type = 'message';\nmsg.payload.content = \"C'est parti pour \" + messageId +\"! L'activation peut prendre jusqu'à 5 minutes.\";\nmsg.payload.device = messageId;\n// You could also send a editMessageReplyMarkup with an empty reply_markup here\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1670,
        "y": 240,
        "wires": [
            [
                "2ee8e04601530170",
                "e0d61a319828c158",
                "5a4e0a89eeaa98cd"
            ]
        ]
    },
    {
        "id": "ee818379b18317d1",
        "type": "switch",
        "z": "bd7fdadec2d6549d",
        "name": "check callback data",
        "property": "payload.content",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "0",
                "vt": "str"
            },
            {
                "t": "istype",
                "v": "string",
                "vt": "string"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 3,
        "x": 1490,
        "y": 280,
        "wires": [
            [
                "f7881f2007e15921"
            ],
            [
                "6cc7c96871c91a10"
            ],
            [
                "e20a496257c44748"
            ]
        ]
    },
    {
        "id": "5a4e0a89eeaa98cd",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "Remove message",
        "func": "// Hide the keyboard and forget the messageId\nmsg.payload.type = 'deleteMessage';\nmsg.payload.content = context.global.keyboard.messageId\ncontext.global.keyboard.messageId = null;\n\n// You could also send a editMessageReplyMarkup with an empty reply_markup here\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1890,
        "y": 260,
        "wires": [
            [
                "e0d61a319828c158"
            ]
        ]
    },
    {
        "id": "e48bd9e45ab3fe21",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "filtre",
        "func": "if (msg.payload.chatId== flow.get(\"$parent.chatId\")){\n    return msg;\n}\n\nelse ;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1310,
        "y": 280,
        "wires": [
            [
                "ee818379b18317d1"
            ]
        ]
    },
    {
        "id": "6cc7c96871c91a10",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "annulation",
        "func": "// Hide the keyboard and forget the messageId\nmsg.payload.type = 'message';\nmsg.payload.content = \"Annulation.\"\n\n// You could also send a editMessageReplyMarkup with an empty reply_markup here\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 280,
        "wires": [
            [
                "e0d61a319828c158",
                "5a4e0a89eeaa98cd"
            ]
        ]
    },
    {
        "id": "e20a496257c44748",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "confirmation",
        "func": "// This is the message id of the initial keyboard that is simply exchanged by a new one.\nvar messageId = context.global.keyboard.messageId;\ncontext.global.keyboard.Id = msg.payload.content;\n\n// This is a sample of how to send a second inline keyboard with modified buttons\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n                {\n                    \"text\": msg.payload.content + \", sûr ?\",\n                    \"callback_data\": \"1\"        \n                }, \n                {\n                    \"text\": \"Fausse manip !\",\n                    \"callback_data\": \"0\"           \n                }]\n            ]\n  });\n\n\nvar options = {\n    chat_id : msg.payload.chatId,\n    reply_markup : reply_markup,\n    message_id : messageId\n};\n\nmsg.payload.type = 'editMessageReplyMarkup';\nmsg.payload.content = reply_markup;\nmsg.payload.options = options;\n\nreturn [ msg ];\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 320,
        "wires": [
            [
                "e0d61a319828c158"
            ]
        ]
    },
    {
        "id": "375abb38d2950b09",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "bme680",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"HR\": msg.payload.uplink_message.decoded_payload[\"HR\"],\n  \"T\": msg.payload.uplink_message.decoded_payload[\"T\"],\n  \"P\": msg.payload.uplink_message.decoded_payload[\"P\"],\n  \"IAQ\": msg.payload.uplink_message.decoded_payload[\"IAQ\"]\n};\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 260,
        "wires": [
            [
                "d35518380c2038d5"
            ]
        ]
    },
    {
        "id": "241eee23f252cc9d",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "pslb",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {};\n\nif (msg.payload.uplink_message.f_port == 2) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": (msg.payload.uplink_message.decoded_payload.bytes[0]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[1],\n        \"model\": (msg.payload.uplink_message.decoded_payload.bytes[2]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[3],\n        \"value\": (msg.payload.uplink_message.decoded_payload.bytes[4]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[5],\n        \"value2\": (msg.payload.uplink_message.decoded_payload.bytes[6]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[7],\n        \"value3\": (msg.payload.uplink_message.decoded_payload.bytes[8])\n    };\n}\n\nif (msg.payload.uplink_message.f_port == 5) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": (msg.payload.uplink_message.decoded_payload.bytes[5]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[6]\n    };\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 460,
        "wires": [
            [
                "4cd9e02a7c54fa5d"
            ]
        ]
    },
    {
        "id": "ab69ac2d5c597e24",
        "type": "switch",
        "z": "bd7fdadec2d6549d",
        "name": "Dragino Interface",
        "property": "payload.end_device_ids.device_id",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "pslb",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "ps-lb",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "sn50",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 290,
        "y": 480,
        "wires": [
            [
                "241eee23f252cc9d"
            ],
            [
                "241eee23f252cc9d"
            ],
            [
                "0a3241dc5c89f34d"
            ]
        ]
    },
    {
        "id": "3fd947473024feec",
        "type": "switch",
        "z": "bd7fdadec2d6549d",
        "name": "Dragino sensor",
        "property": "payload.end_device_ids.device_id",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "tracker",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lwl02",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lds02",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lht52",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lht65",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "dds45",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "dds75",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lds12",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "llds12",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "aiso1",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "ais01",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lms01",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "s31",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "cpl03",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "aqs01",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "dds20",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 16,
        "x": 280,
        "y": 680,
        "wires": [
            [
                "07c1b146dfa53a80"
            ],
            [
                "d5636560cbaea6cc"
            ],
            [
                "2abf26790d7e0a30"
            ],
            [
                "c3603c66ba5590c4"
            ],
            [
                "37e30a9394b81303"
            ],
            [
                "bc10e290ac26a78e"
            ],
            [
                "13b23bd224c7c975"
            ],
            [
                "781d80975f9cea67"
            ],
            [
                "781d80975f9cea67"
            ],
            [],
            [
                "224b1438f282def3",
                "94c3a36b2516e09f"
            ],
            [
                "56355e487a7e130b"
            ],
            [
                "9490d1aeb5443d73"
            ],
            [
                "66f7776a7cf4f55a"
            ],
            [
                "d89d0457592144ba"
            ],
            [
                "bc10e290ac26a78e"
            ]
        ]
    },
    {
        "id": "07c1b146dfa53a80",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "trackerD",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {}\n\nif (msg.payload.uplink_message.f_port==2) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"humidity\": msg.payload.uplink_message.decoded_payload[\"Hum\"],\n        \"temperature\": msg.payload.uplink_message.decoded_payload[\"Tem\"],\n        \"latitude\": msg.payload.uplink_message.decoded_payload[\"Latitude\"],\n        \"longitude\": msg.payload.uplink_message.decoded_payload[\"Longitude\"]\n     };\n}\n\nif (msg.payload.uplink_message.f_port == 5) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": msg.payload.uplink_message.decoded_payload[\"BatV\"],\n    };\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 600,
        "wires": [
            [
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "2abf26790d7e0a30",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "lds02",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"battery\": msg.payload.uplink_message.decoded_payload[\"BAT_V\"],\n  \"value\": msg.payload.uplink_message.decoded_payload[\"DOOR_OPEN_STATUS\"]\n};\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 680,
        "wires": [
            [
                "b0b0208ec402979f",
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "c3603c66ba5590c4",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "lht52",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {}\n\nif (msg.payload.uplink_message.f_port==2) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"humidity\": msg.payload.uplink_message.decoded_payload[\"Hum_SHT\"],\n        \"temperature\": msg.payload.uplink_message.decoded_payload[\"TempC_SHT\"],\n        \"temperature_sonde\": msg.payload.uplink_message.decoded_payload[\"TempC_DS\"]\n     };\n}\n\nif (msg.payload.uplink_message.f_port == 5) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": msg.payload.uplink_message.decoded_payload[\"Bat_mV\"],\n   };\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 720,
        "wires": [
            [
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "37e30a9394b81303",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "lht65",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {}\n\nif (msg.payload.uplink_message.f_port==2) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"humidity\": msg.payload.uplink_message.decoded_payload[\"Hum_SHT\"],\n        \"temperature\": msg.payload.uplink_message.decoded_payload[\"TempC_SHT\"],\n        \"battery\": msg.payload.uplink_message.decoded_payload[\"BatV\"],\n        \"temperature_sonde\": msg.payload.uplink_message.decoded_payload[\"TempC_DS\"]\n     };\n}\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 760,
        "wires": [
            [
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "bc10e290ac26a78e",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "dds45 (ultrason)",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar distanceStr = msg.payload.uplink_message.decoded_payload[\"Distance\"];\nvar distance = parseInt(distanceStr, 10); // Convertit \"1200mm\" en 1200\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"value\": distance,\n  \"battery\": msg.payload.uplink_message.decoded_payload[\"Bat\"],\n  \"tempC\": msg.payload.uplink_message.decoded_payload[\"TempC_DS18B20\"]\n};\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 800,
        "wires": [
            [
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "13b23bd224c7c975",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "dds75 (ultrason)",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar distanceStr = msg.payload.uplink_message.decoded_payload[\"Distance\"];\nvar distance = parseInt(distanceStr, 10); // Convertit \"1200cm\" en 1200\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"value\": msg.payload.uplink_message.decoded_payload[\"value\"],\n};\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 840,
        "wires": [
            [
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "781d80975f9cea67",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "lds (lidar)",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"value\": msg.payload.uplink_message.decoded_payload[\"Lidar_distance\"],\n  \"battery\": msg.payload.uplink_message.decoded_payload[\"Bat\"],\n  \"temp\": msg.payload.uplink_message.decoded_payload[\"Lidar_temp\"]\n};\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 880,
        "wires": [
            [
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "224b1438f282def3",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "d": true,
        "name": "ais01",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": ((msg.payload.uplink_message.decoded_payload.bytes[0] << 8) | msg.payload.uplink_message.decoded_payload.bytes[1]),\n    \"value\": (\n        ((msg.payload.uplink_message.decoded_payload.bytes[6] << 24) |\n            (msg.payload.uplink_message.decoded_payload.bytes[7] << 16) |\n            (msg.payload.uplink_message.decoded_payload.bytes[8] << 8) |\n            msg.payload.uplink_message.decoded_payload.bytes[9]) +\n        ((msg.payload.uplink_message.decoded_payload.bytes[10] << 24) |\n            (msg.payload.uplink_message.decoded_payload.bytes[11] << 16) |\n            (msg.payload.uplink_message.decoded_payload.bytes[12] << 8) |\n            msg.payload.uplink_message.decoded_payload.bytes[13]) / Math.pow(10, 8)\n    )\n};\n\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 920,
        "wires": [
            [
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "d5636560cbaea6cc",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "lwl02",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": msg.payload.uplink_message.decoded_payload[\"BAT_V\"],\n        \"value\": msg.payload.uplink_message.decoded_payload[\"WATER_LEAK_STATUS\"]\n    };\nmsg.payload=message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 640,
        "wires": [
            [
                "7c59f22ab7f8b22d",
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "c15299ef6a8aa811",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "Porte",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"battery\": msg.payload.uplink_message.decoded_payload[\"BAT_V\"],\n  \"value\": msg.payload.uplink_message.decoded_payload[\"DOOR_OPEN_STATUS\"]\n};\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 180,
        "wires": [
            [
                "378d1b52bef108b9",
                "d35518380c2038d5"
            ]
        ]
    },
    {
        "id": "7c59f22ab7f8b22d",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "Alerte lwl02",
        "func": "var devicesData = flow.get(\"$parent.waterlow\");\nvar msg2 = msg.payload;\nvar oldValue ;\nvar alerte = \"\";\n\n// Vérifier si l'array existe déjà dans le contexte\nif (!devicesData) {\n  devicesData = []; // Si l'array n'existe pas, initialisez-le avec un array vide\n}\n\n\n// Rechercher l'index de l'élément correspondant au \"capteur 2\" dans l'array\nvar capteurIndex = devicesData.findIndex(function (device) {\n  return device.name === msg2.name;\n});\n\n// Vérifier si l'élément \"capteur 2\" a été trouvé\nif (capteurIndex !== -1) {\n\n    oldValue = devicesData[capteurIndex].state;\n    // Le \"capteur\" existe dans l'array, mettez à jour son état\n    devicesData[capteurIndex].state = msg2.value;\n    \n} else {\n  // Le \"capteur\" n'existe pas dans l'array, donc nous allons le créer\n  var nouveauCapteur = {\n    \"name\": msg2.name,\n    \"state\": msg2.value}\n  ;\n  devicesData.push(nouveauCapteur);\n}\n\n// Fonction de comparaison pour trier par ordre alphabétique des noms\nfunction compareName(a, b) {\n  var nameA = a.name.toLowerCase();\n  var nameB = b.name.toLowerCase();\n  if (nameA < nameB) return -1;\n  if (nameA > nameB) return 1;\n  return 0;\n}\n\n// Trier l'array par ordre alphabétique des noms des capteurs en utilisant la fonction de comparaison\ndevicesData.sort(compareName);\n\n// Enregistrer à nouveau l'array trié dans la variable de contexte \"devicesData\"\nflow.set(\"$parent.waterlow\", devicesData);\n\n// Envoi alerte si l'état a changé\nmsg.telegram={};\n\nif (oldValue != msg.payload.value){\n    oldValue = msg.payload.value;\n    msg.telegram.payload={}\n    msg.telegram.payload.chatId = flow.get(\"$parent.chatId\");\n    msg.telegram.payload.content = \"le \" + msg2.name + \" passe en \" + msg2.value ;\n    msg.telegram.payload.type = \"message\";\n    return msg.telegram;\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 640,
        "wires": [
            [
                "268bd8bf3a8d4924"
            ]
        ]
    },
    {
        "id": "b0b0208ec402979f",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "Alerte lds02",
        "func": "var devicesData = flow.get(\"$parent.porte\");\nvar msg2 = msg.payload;\nvar oldValue;\nvar alerte = \"\";\n\n// Vérifier si l'array existe déjà dans le contexte\nif (!devicesData) {\n  devicesData = []; // Si l'array n'existe pas, initialisez-le avec un array vide\n}\n\n\n// Rechercher l'index de l'élément correspondant au \"capteur 2\" dans l'array\nvar capteurIndex = devicesData.findIndex(function (device) {\n  return device.name === msg2.name;\n});\n\n// Vérifier si l'élément \"capteur 2\" a été trouvé\nif (capteurIndex !== -1) {\n\n  oldValue = devicesData[capteurIndex].state;\n  // Le \"capteur\" existe dans l'array, mettez à jour son état\n  devicesData[capteurIndex].state = msg2.value;\n\n} else {\n  // Le \"capteur\" n'existe pas dans l'array, donc nous allons le créer\n  var nouveauCapteur = {\n    \"name\": msg2.name,\n    \"state\": msg2.value,\n    \"power\": msg2.power\n  }\n    ;\n  devicesData.push(nouveauCapteur);\n}\n\n// Fonction de comparaison pour trier par ordre alphabétique des noms\nfunction compareName(a, b) {\n  var nameA = a.name.toLowerCase();\n  var nameB = b.name.toLowerCase();\n  if (nameA < nameB) return -1;\n  if (nameA > nameB) return 1;\n  return 0;\n}\n\n// Trier l'array par ordre alphabétique des noms des capteurs en utilisant la fonction de comparaison\ndevicesData.sort(compareName);\n\n// Enregistrer à nouveau l'array trié dans la variable de contexte \"devicesData\"\nflow.set(\"$parent.porte\", devicesData);\n\n// Envoi alerte si l'état a changé\nmsg.telegram = {};\n\nif (oldValue != msg.payload.value) {\n  oldValue = msg.payload.value;\n  msg.telegram.payload = {}\n  msg.telegram.payload.chatId = flow.get(\"$parent.chatId\");\n  msg.telegram.payload.content = \"la \" + msg2.name + \" passe en \" + msg2.value;\n  msg.telegram.payload.type = \"message\";\n  return msg.telegram;\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 680,
        "wires": [
            [
                "268bd8bf3a8d4924"
            ]
        ]
    },
    {
        "id": "e27efcb5fecdc72c",
        "type": "link in",
        "z": "bd7fdadec2d6549d",
        "name": "link in 1",
        "links": [
            "bc2d357bdba3f210",
            "d35518380c2038d5",
            "4cd9e02a7c54fa5d",
            "7bd3694006f92436"
        ],
        "x": 145,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "bc2d357bdba3f210",
        "type": "link out",
        "z": "bd7fdadec2d6549d",
        "name": "link out 1",
        "mode": "link",
        "links": [
            "e27efcb5fecdc72c"
        ],
        "x": 785,
        "y": 760,
        "wires": []
    },
    {
        "id": "d35518380c2038d5",
        "type": "link out",
        "z": "bd7fdadec2d6549d",
        "name": "link out 2",
        "mode": "link",
        "links": [
            "e27efcb5fecdc72c"
        ],
        "x": 985,
        "y": 60,
        "wires": []
    },
    {
        "id": "296ef8a47fb4047a",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "msg",
        "func": "if (msg.payload.chatId== flow.get(\"$parent.chatId\")){\n    \n    //msg.payload={}\n    msg.payload.chatId = msg.payload.chatId;\n\n    // Récupérer l'array \"devicesData\" depuis la variable de contexte\n    var devicesData = flow.get(\"$parent.porte\");\n    \n    if (Array.isArray(devicesData)) {\n      // Générer le message avec l'état des capteurs\n      var message = \"État des portes :\\n\";\n    \n      devicesData.forEach(function (device) {\n        message += device.name + \" : \" + device.state + \"\\n\";\n      });\n    \n      msg.payload.content = message;\n      return msg;\n    } \n    \n    else {\n      msg.payload.content = \"Aucune porte trouvé !\";\n    }\n    \n    msg.payload.type = \"message\";\n    return msg\n}\nelse {}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1270,
        "y": 120,
        "wires": [
            [
                "d44931fe0ec84601"
            ]
        ]
    },
    {
        "id": "4cd9e02a7c54fa5d",
        "type": "link out",
        "z": "bd7fdadec2d6549d",
        "name": "link out 3",
        "mode": "link",
        "links": [
            "e27efcb5fecdc72c"
        ],
        "x": 795,
        "y": 440,
        "wires": []
    },
    {
        "id": "0a5586cdb658de53",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "gestion_lancelot",
        "func": "var devicesData = flow.get(\"$parent.lancelot\");\nvar msg2 = msg.payload;\nmsg2.value=0;\nvar oldValue ;\nvar alerte = \"\";\n\n// Vérifier si l'array existe déjà dans le contexte\nif (!devicesData) {\n  devicesData = []; // Si l'array n'existe pas, initialisez-le avec un array vide\n}\n\n\n// Rechercher l'index de l'élément correspondant au \"capteur 2\" dans l'array\nvar capteurIndex = devicesData.findIndex(function (device) {\n  return device.name === msg2.name;\n});\n\n// Vérifier si l'élément \"capteur 2\" a été trouvé\nif (capteurIndex !== -1) {\n\n    oldValue = devicesData[capteurIndex].state;\n    // Le \"capteur\" existe dans l'array, mettez à jour son état\n    devicesData[capteurIndex].state = msg2.value;\n    \n} else {\n  // Le \"capteur\" n'existe pas dans l'array, donc nous allons le créer\n  var nouveauCapteur = {\n    \"name\": msg2.name,\n    \"state\": msg2.value}\n  ;\n  devicesData.push(nouveauCapteur);\n}\n\n// Fonction de comparaison pour trier par ordre alphabétique des noms\nfunction compareName(a, b) {\n  var nameA = a.name.toLowerCase();\n  var nameB = b.name.toLowerCase();\n  if (nameA < nameB) return -1;\n  if (nameA > nameB) return 1;\n  return 0;\n}\n\n// Trier l'array par ordre alphabétique des noms des capteurs en utilisant la fonction de comparaison\ndevicesData.sort(compareName);\n\n// Enregistrer à nouveau l'array trié dans la variable de contexte \"devicesData\"\nflow.set(\"$parent.lancelot\", devicesData);\n\n// Envoi alerte si l'état a changé\nmsg.telegram={};\n\nif (oldValue != msg.payload.value){\n    oldValue = msg.payload.value;\n    msg.telegram.payload={}\n    msg.telegram.payload.chatId = flow.get(\"$parent.chatId\");\n    msg.telegram.payload.content = \"le \" + msg2.name + \" passe en \" + msg2.value ;\n    msg.telegram.payload.type = \"message\";\n    return msg.telegram;\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 220,
        "wires": [
            [
                "97f3a34543148b88"
            ]
        ]
    },
    {
        "id": "56355e487a7e130b",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "lms01",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": ((msg.payload.uplink_message.decoded_payload.bytes[0] << 8) | msg.payload.uplink_message.decoded_payload.bytes[1]),\n    \"value\": ((msg.payload.uplink_message.decoded_payload.bytes[2] << 8) | msg.payload.uplink_message.decoded_payload.bytes[3]),\n    \"value2\": ((msg.payload.uplink_message.decoded_payload.bytes[4] << 8) | msg.payload.uplink_message.decoded_payload.bytes[5]),\n    \"value3\": ((msg.payload.uplink_message.decoded_payload.bytes[6] << 8) | msg.payload.uplink_message.decoded_payload.bytes[7]),\n};\n\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 960,
        "wires": [
            [
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "0a3241dc5c89f34d",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "sn50v3",
        "func": "// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": 1,\n    \"snr\": 1,\n    \"battery\": (msg.payload.uplink_message.decoded_payload.bytes[11]),\n    \"value\": (msg.payload.uplink_message.decoded_payload.bytes[0]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[1],\n    \"value2\": (msg.payload.uplink_message.decoded_payload.bytes[2]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[3],\n    \"value3\": (msg.payload.uplink_message.decoded_payload.bytes[4]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[5],\n};\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 500,
        "wires": [
            [
                "4cd9e02a7c54fa5d"
            ]
        ]
    },
    {
        "id": "abd2a74a209347b5",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "furgo",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": msg.payload.uplink_message.decoded_payload[\"BatV\"],\n    \"value\": (msg.payload.uplink_message.decoded_payload[\"ADC1_V\"])\n};\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 300,
        "wires": [
            [
                "d35518380c2038d5"
            ]
        ]
    },
    {
        "id": "70bc8f3e6d3dcfbb",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "lht52",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {}\n\nif (msg.payload.uplink_message.f_port==2) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"humidity\": msg.payload.uplink_message.decoded_payload[\"Hum_SHT\"],\n        \"temperature\": msg.payload.uplink_message.decoded_payload[\"TempC_SHT\"],\n        \"temperature_sonde\": msg.payload.uplink_message.decoded_payload[\"TempC_DS\"]\n     };\n}\n\nif (msg.payload.uplink_message.f_port == 5) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": msg.payload.uplink_message.decoded_payload[\"Bat_mV\"],\n   };\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 340,
        "wires": [
            [
                "d35518380c2038d5"
            ]
        ]
    },
    {
        "id": "9490d1aeb5443d73",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "s31",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": msg.payload.uplink_message.decoded_payload[\"BatV\"],\n    \"temperature\": msg.payload.uplink_message.decoded_payload[\"TempC_SHT\"],\n    \"humidity\": msg.payload.uplink_message.decoded_payload[\"Hum_SHT\"]\n};\n\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 1000,
        "wires": [
            [
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "73ef40b751c41f01",
        "type": "debug",
        "z": "bd7fdadec2d6549d",
        "name": "debug 110",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1430,
        "y": 20,
        "wires": []
    },
    {
        "id": "28ca1e761dde49fb",
        "type": "debug",
        "z": "bd7fdadec2d6549d",
        "name": "debug 113",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1570,
        "y": 160,
        "wires": []
    },
    {
        "id": "66f7776a7cf4f55a",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "cpl03",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": 0,\n    \"value\": (msg.payload.uplink_message.decoded_payload.bytes[0])\n};\n\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 1040,
        "wires": [
            [
                "379c6a73fe486a58",
                "5f6723f9484cced1",
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "379c6a73fe486a58",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "Alerte cpl03",
        "func": "var devicesData = flow.get(\"$parent.cpl03\");\nvar msg2 = msg.payload;\nvar oldValue ;\nvar alerte = \"\";\n\n// Vérifier si l'array existe déjà dans le contexte\nif (!devicesData) {\n  devicesData = []; // Si l'array n'existe pas, initialisez-le avec un array vide\n}\n\n\n// Rechercher l'index de l'élément correspondant au \"capteur 2\" dans l'array\nvar capteurIndex = devicesData.findIndex(function (device) {\n  return device.name === msg2.name;\n});\n\n// Vérifier si l'élément \"capteur 2\" a été trouvé\nif (capteurIndex !== -1) {\n\n    oldValue = devicesData[capteurIndex].state;\n    // Le \"capteur\" existe dans l'array, mettez à jour son état\n    devicesData[capteurIndex].state = msg2.value;\n    \n} else {\n  // Le \"capteur\" n'existe pas dans l'array, donc nous allons le créer\n  var nouveauCapteur = {\n    \"name\": msg2.name,\n    \"state\": msg2.value}\n  ;\n  devicesData.push(nouveauCapteur);\n}\n\n// Fonction de comparaison pour trier par ordre alphabétique des noms\nfunction compareName(a, b) {\n  var nameA = a.name.toLowerCase();\n  var nameB = b.name.toLowerCase();\n  if (nameA < nameB) return -1;\n  if (nameA > nameB) return 1;\n  return 0;\n}\n\n// Trier l'array par ordre alphabétique des noms des capteurs en utilisant la fonction de comparaison\ndevicesData.sort(compareName);\n\n// Enregistrer à nouveau l'array trié dans la variable de contexte \"devicesData\"\nflow.set(\"$parent.cpl03\", devicesData);\n\n// Envoi alerte si l'état a changé\nmsg.telegram={};\n\nif (oldValue != msg.payload.value){\n    oldValue = msg.payload.value;\n    msg.telegram.payload={}\n    msg.telegram.payload.chatId = flow.get(\"$parent.chatId\");\n    msg.telegram.payload.content = \"le \" + msg2.name + \" passe en \" + msg2.value ;\n    msg.telegram.payload.type = \"message\";\n    return msg.telegram;\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 1040,
        "wires": [
            [
                "268bd8bf3a8d4924"
            ]
        ]
    },
    {
        "id": "5f6723f9484cced1",
        "type": "debug",
        "z": "bd7fdadec2d6549d",
        "name": "debug 117",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 630,
        "y": 1080,
        "wires": []
    },
    {
        "id": "94c3a36b2516e09f",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "ais01",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar bytes = msg.payload.uplink_message.decoded_payload.bytes;\n\n// Reconstituer la partie entière (bytes 6 à 9) — 4 octets\n// On combine les 4 octets en un entier 32 bits (big endian)\nvar integerPart = (bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9];\n\n// Reconstituer la partie décimale (bytes 10 à 13) — 4 octets\nvar decimalPart = (bytes[10] << 24) | (bytes[11] << 16) | (bytes[12] << 8) | bytes[13];\n\n// Pour éviter les problèmes liés au bit de signe lors du décalage à gauche (car JS utilise 32 bits signés)\n// Convertir en unsigned via >>> 0 :\nintegerPart = integerPart >>> 0;\ndecimalPart = decimalPart >>> 0;\n\n// Calculer la valeur finale (en considérant que la partie décimale est divisée par 10^n)\n// Ici on suppose que la partie décimale représente des chiffres après la virgule, par exemple 4 chiffres, donc division par 10000\nvar value = integerPart + (decimalPart / 10000);\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": ((msg.payload.uplink_message.decoded_payload.bytes[0] << 8) | msg.payload.uplink_message.decoded_payload.bytes[1]),\n    \"value\":value,\n    \"byte6\": bytes[6],\n    \"byte7\": bytes[7],\n    \"byte8\": bytes[8],\n    \"byte9\": bytes[9],\n    \"byte10\": bytes[10],\n    \"byte11\": bytes[11],\n    \"byte12\": bytes[12],\n    \"byte13\": bytes[13]\n};\n\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 1080,
        "wires": [
            [
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "391656f407ad734e",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "davele",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": msg.payload.uplink_message.decoded_payload.bytes[0],\n    \"distance\": ((msg.payload.uplink_message.decoded_payload.bytes[1] * 256) + msg.payload.uplink_message.decoded_payload.bytes[2]),\n    \"bpm\": msg.payload.uplink_message.decoded_payload.bytes[3],\n    \"lux\": msg.payload.uplink_message.decoded_payload.bytes[4]\n};\n\n// Vérifie si msg.payload.uplink_message.decoded_payload.bytes[3] existe\nif (msg.payload.uplink_message.decoded_payload.bytes[3] !== undefined) {\n    // Si oui, ajoute la deuxième valeur\n    message.value2 = ((msg.payload.uplink_message.decoded_payload.bytes[3] * 256) + msg.payload.uplink_message.decoded_payload.bytes[4]);\n}\n\n// Vérifie si msg.payload.uplink_message.decoded_payload.bytes[3] existe\nif (msg.payload.uplink_message.decoded_payload.bytes[5] !== undefined) {\n    // Si oui, ajoute la deuxième valeur\n    message.value3 = ((msg.payload.uplink_message.decoded_payload.bytes[5] * 256) + msg.payload.uplink_message.decoded_payload.bytes[6]);\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 380,
        "wires": [
            [
                "d35518380c2038d5"
            ]
        ]
    },
    {
        "id": "d89d0457592144ba",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "aqs01",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {}\n\nif (msg.payload.uplink_message.f_port==2) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": ((msg.payload.uplink_message.decoded_payload.bytes[0] << 8) | msg.payload.uplink_message.decoded_payload.bytes[1]),\n        \"temperature\": ((msg.payload.uplink_message.decoded_payload.bytes[2] << 8) | msg.payload.uplink_message.decoded_payload.bytes[3]),\n        \"humidity\": ((msg.payload.uplink_message.decoded_payload.bytes[4] << 8) | msg.payload.uplink_message.decoded_payload.bytes[5]),\n        \"pressure\": ((msg.payload.uplink_message.decoded_payload.bytes[6] << 8) | msg.payload.uplink_message.decoded_payload.bytes[7]),\n        \"co2\": ((msg.payload.uplink_message.decoded_payload.bytes[8] << 8) | msg.payload.uplink_message.decoded_payload.bytes[9])\n     };\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 1120,
        "wires": [
            [
                "bc2d357bdba3f210"
            ]
        ]
    },
    {
        "id": "8d50ae7fda2a3a3c",
        "type": "switch",
        "z": "bd7fdadec2d6549d",
        "name": "milesight Interface",
        "property": "payload.end_device_ids.device_id",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "em300",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 290,
        "y": 1180,
        "wires": [
            [
                "a7d02b92a5fe2636"
            ]
        ]
    },
    {
        "id": "a7d02b92a5fe2636",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "em300",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"humidity\": msg.payload.uplink_message.decoded_payload[\"humidity\"],\n  \"battery\": msg.payload.uplink_message.decoded_payload[\"battery\"],\n  \"temperature\": msg.payload.uplink_message.decoded_payload[\"temperature\"]\n};\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 1180,
        "wires": [
            [
                "7bd3694006f92436"
            ]
        ]
    },
    {
        "id": "7bd3694006f92436",
        "type": "link out",
        "z": "bd7fdadec2d6549d",
        "name": "link out 4",
        "mode": "link",
        "links": [
            "e27efcb5fecdc72c"
        ],
        "x": 785,
        "y": 1180,
        "wires": []
    },
    {
        "id": "03ef47d8c3e7dea2",
        "type": "telegram command",
        "z": "bd7fdadec2d6549d",
        "d": true,
        "name": "hello",
        "command": "/hello",
        "description": "",
        "registercommand": false,
        "language": "",
        "scope": "default",
        "bot": "36f1cf07c6e6ca84",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 1130,
        "y": 40,
        "wires": [
            [
                "4e09185f9dae5f10",
                "73ef40b751c41f01"
            ],
            []
        ]
    },
    {
        "id": "aed79bce46f130fe",
        "type": "telegram command",
        "z": "bd7fdadec2d6549d",
        "d": true,
        "name": "Waterlow",
        "command": "/waterlow",
        "description": "",
        "registercommand": false,
        "language": "",
        "scope": "default",
        "bot": "36f1cf07c6e6ca84",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 1140,
        "y": 80,
        "wires": [
            [
                "607a2d97902e1510"
            ],
            []
        ]
    },
    {
        "id": "78afd854740fef74",
        "type": "telegram command",
        "z": "bd7fdadec2d6549d",
        "d": true,
        "name": "Lancelot",
        "command": "/Lancelot",
        "description": "",
        "registercommand": false,
        "language": "",
        "scope": "default",
        "bot": "36f1cf07c6e6ca84",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 1140,
        "y": 180,
        "wires": [
            [
                "8e9f98201941b052"
            ],
            []
        ]
    },
    {
        "id": "d6196ece20f74f66",
        "type": "telegram command",
        "z": "bd7fdadec2d6549d",
        "d": true,
        "name": "lancelot",
        "command": "/lancelot",
        "description": "",
        "registercommand": false,
        "language": "",
        "scope": "default",
        "bot": "36f1cf07c6e6ca84",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 1130,
        "y": 220,
        "wires": [
            [
                "8e9f98201941b052"
            ],
            []
        ]
    },
    {
        "id": "15f666b30a9449f4",
        "type": "telegram command",
        "z": "bd7fdadec2d6549d",
        "d": true,
        "name": "Portes",
        "command": "/porte",
        "description": "",
        "registercommand": false,
        "language": "",
        "scope": "default",
        "bot": "36f1cf07c6e6ca84",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 1130,
        "y": 120,
        "wires": [
            [
                "296ef8a47fb4047a"
            ],
            []
        ]
    },
    {
        "id": "9967c5fa312e6bde",
        "type": "telegram event",
        "z": "bd7fdadec2d6549d",
        "d": true,
        "name": "",
        "bot": "36f1cf07c6e6ca84",
        "event": "callback_query",
        "autoanswer": true,
        "x": 1160,
        "y": 280,
        "wires": [
            [
                "e48bd9e45ab3fe21"
            ]
        ]
    },
    {
        "id": "d44931fe0ec84601",
        "type": "telegram sender",
        "z": "bd7fdadec2d6549d",
        "d": true,
        "name": "Send msg",
        "bot": "36f1cf07c6e6ca84",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1420,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "f95598d381025cd5",
        "type": "telegram sender",
        "z": "bd7fdadec2d6549d",
        "d": true,
        "name": "Send msg",
        "bot": "36f1cf07c6e6ca84",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1420,
        "y": 200,
        "wires": [
            [
                "31c88bf4584eb6aa",
                "28ca1e761dde49fb"
            ]
        ]
    },
    {
        "id": "e0d61a319828c158",
        "type": "telegram sender",
        "z": "bd7fdadec2d6549d",
        "d": true,
        "name": "send",
        "bot": "36f1cf07c6e6ca84",
        "haserroroutput": false,
        "outputs": 1,
        "x": 2010,
        "y": 340,
        "wires": [
            []
        ]
    },
    {
        "id": "268bd8bf3a8d4924",
        "type": "telegram sender",
        "z": "bd7fdadec2d6549d",
        "d": true,
        "name": "Send msg",
        "bot": "36f1cf07c6e6ca84",
        "haserroroutput": false,
        "outputs": 1,
        "x": 920,
        "y": 840,
        "wires": [
            []
        ]
    },
    {
        "id": "97f3a34543148b88",
        "type": "telegram sender",
        "z": "bd7fdadec2d6549d",
        "d": true,
        "name": "Send msg",
        "bot": "36f1cf07c6e6ca84",
        "haserroroutput": false,
        "outputs": 1,
        "x": 900,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "fe9a13e81e796e07",
        "type": "function",
        "z": "bd7fdadec2d6549d",
        "name": "latex",
        "func": "// Récupération du RSSI et SNR maximum\nvar maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var rssi = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var snr = msg.payload.uplink_message.rx_metadata[i].snr;\n    if (rssi > maxRSSI) maxRSSI = rssi;\n    if (snr > maxSNR) maxSNR = snr;\n}\n\n// Raccourci vers le tableau de bytes\nvar b = msg.payload.uplink_message.decoded_payload.bytes;\n\n// Construction du message de sortie\nmsg.payload = {\n    name: msg.payload.end_device_ids.device_id,\n    rssi: maxRSSI,\n    snr: maxSNR,\n    min: (b[0] << 8) + b[1],              // mm\n    max: (b[2] << 8) + b[3],              // mm\n    mean: ((b[4] << 8) + b[5]) / 10.0,     // mm, 1 décimale\n    sd: ((b[6] << 8) + b[7]) / 10.0,      // mm, 1 décimale\n    median: ((b[8] << 8) + b[9]),      // mm\n    validCount : b[10],\n    battery: b[11]\n};\n\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 420,
        "wires": [
            [
                "d35518380c2038d5"
            ]
        ]
    },
    {
        "id": "07c07b6c8d5dcfeb",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "contextData",
        "func": "// Récupérer le contexte global\nlet apps = flow.get(\"apps\", \"file\") || {};\n\n// Récupérer les données du message TTN\nlet data = msg.payload;\n\n// Extraire les infos principales\nlet appID = data?.end_device_ids?.application_ids?.application_id;\nlet deviceID = data?.end_device_ids?.device_id;\nlet rssi = data?.uplink_message?.rx_metadata?.[0]?.rssi;\nlet snr = data?.uplink_message?.rx_metadata?.[0]?.snr;\nlet decoded = data?.uplink_message?.decoded_payload;\n\n// Vérifications minimales\nif (!appID || !deviceID) {\n    node.warn(\"AppID ou DeviceID manquant\");\n    return null;\n}\n\n// Si l'application n'existe pas encore, on la crée\nif (!apps[appID]) {\n    apps[appID] = {\n        chatID: \"000\",\n        sensors: {}\n    };\n}\n\n// Si le capteur n'existe pas encore, on le crée\nif (!apps[appID].sensors[deviceID]) {\n    apps[appID].sensors[deviceID] = {};\n}\n\n// Mise à jour des données du capteur\napps[appID].sensors[deviceID] = {\n    ...apps[appID].sensors[deviceID],\n    rssi: rssi,\n    snr: snr,\n    lastUpdate: new Date().toISOString(),\n    decoded_payload: decoded\n};\n\n// Sauvegarde dans le contexte global\nflow.set(\"apps\", apps, \"file\");\n\n// Optionnel : renvoyer un message pour debug ou suite du flow\nmsg.payload = apps;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 120,
        "wires": [
            [
                "e6d8a58cb5193150"
            ]
        ]
    },
    {
        "id": "05b66f0643623976",
        "type": "inject",
        "z": "02a9741c1b0f658d",
        "name": "Inject template",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"end_device_ids\":{\"device_id\":\"latex-01\",\"application_ids\":{\"application_id\":\"mobilab-truck\"},\"dev_eui\":\"70B3D57ED0072D6C\",\"join_eui\":\"0000000000000000\",\"dev_addr\":\"260B7E4E\"},\"correlation_ids\":[\"gs:uplink:01K71FCN0MB0BA21P7D3NQ1TSW\"],\"received_at\":\"2025-10-08T08:35:47.556876883Z\",\"uplink_message\":{\"session_key_id\":\"AZl2rHHCAzLVJCH6gefqcg==\",\"f_port\":1,\"f_cnt\":18339,\"frm_payload\":\"AC4ANgHxABgAMiRO\",\"decoded_payload\":{\"bytes\":[0,46,0,54,1,241,0,24,0,50,36,78]},\"rx_metadata\":[{\"gateway_ids\":{\"gateway_id\":\"lisah-ug65-1\",\"eui\":\"24E124FFFEF7E3D6\"},\"time\":\"2025-10-08T08:35:47.328Z\",\"timestamp\":403505293,\"rssi\":-82,\"channel_rssi\":-82,\"snr\":13.5,\"frequency_offset\":\"230\",\"location\":{\"latitude\":43.61944841808217,\"longitude\":3.857522711001851,\"altitude\":80,\"source\":\"SOURCE_REGISTRY\"},\"uplink_token\":\"ChoKGAoMbGlzYWgtdWc2NS0xEggk4ST//vfj1hCNgbTAARoMCOPEmMcGELDDl6YBIMjNqJbfkekGKgwI48SYxwYQgMSznAE=\",\"channel_index\":3,\"gps_time\":\"2025-10-08T08:35:47.328Z\",\"received_at\":\"2025-10-08T08:35:47.330007620Z\"}],\"settings\":{\"data_rate\":{\"lora\":{\"bandwidth\":125000,\"spreading_factor\":7,\"coding_rate\":\"4/5\"}},\"frequency\":\"867100000\",\"timestamp\":403505293,\"time\":\"2025-10-08T08:35:47.328Z\"},\"received_at\":\"2025-10-08T08:35:47.349656096Z\",\"consumed_airtime\":\"0.061696s\",\"packet_error_rate\":0.04761905,\"network_ids\":{\"net_id\":\"000013\",\"ns_id\":\"EC656E0000000181\",\"tenant_id\":\"ttn\",\"cluster_id\":\"eu1\",\"cluster_address\":\"eu1.cloud.thethings.network\"}}}",
        "payloadType": "json",
        "x": 120,
        "y": 120,
        "wires": [
            [
                "07c07b6c8d5dcfeb"
            ]
        ]
    },
    {
        "id": "22a5779c6bc15798",
        "type": "debug",
        "z": "02a9741c1b0f658d",
        "name": "debug 11",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 380,
        "y": 20,
        "wires": []
    },
    {
        "id": "e6d8a58cb5193150",
        "type": "subflow:bd7fdadec2d6549d",
        "z": "02a9741c1b0f658d",
        "name": "",
        "x": 500,
        "y": 120,
        "wires": [
            [
                "72746091174fdbbf"
            ],
            []
        ]
    },
    {
        "id": "72746091174fdbbf",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "Ajout de values",
        "func": "// Extract all sensor values from the incoming message payload object.\nlet payload = msg.payload;\n\n// Determine the table name from the 'name' field\nlet tableName = payload.name.split('-')[0];\n\n// Define a mapping of table names to their respective fields\nconst fieldsMapping = {\n    'lht52': ['name', 'rssi', 'snr', 'battery', 'humidity', 'temperature', 'temperature_probe'],\n    'pilowtech': ['name', 'rssi', 'snr', 'battery', 'value', 'value2', 'value3'],\n    'latex': ['name', 'rssi', 'snr', 'battery', 'min', 'max', 'mean', 'sd', 'median', 'valid_count'],\n    'pslb': ['name', 'rssi', 'snr', 'battery', 'probe_model', 'idc_in', 'vdc_in']\n};\n\n// Check if the determined table name is valid\nif (fieldsMapping[tableName]) {\n    // Get the fields for the specific table\n    const fields = fieldsMapping[tableName];\n\n    // Construct the field list and the parameter list for the query\n    const fieldList = fields.join(', ');\n    const paramsList = fields.map((field, index) => `$${index + 1}`).join(', ');\n\n    // Construct the parameterized query\n    msg.query = `INSERT INTO ${tableName} (${fieldList}) VALUES (${paramsList})`;\n\n    // Create an array of parameters in the correct order\n    msg.params = fields.map(field => payload[field]);\n\n    return msg;\n} else {\n    // Handle case where the table name is not recognized\n    node.warn(`Unrecognized sensor name prefix: ${tableName}`);\n    return null; // Return null to stop the flow\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "4e4c5b82d23e26ac",
        "type": "switch",
        "z": "02a9741c1b0f658d",
        "name": "Autoconstruction",
        "property": "payload.end_device_ids.device_id",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "pilowtech",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "debit",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "irritrace",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "sel",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "senpow",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "watermark",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "sonar",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "waterlow",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "porte",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lancelot",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "bme680",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "furgo",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "temperature",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "davele",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "latex",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 15,
        "x": 1230,
        "y": 440,
        "wires": [
            [
                "7cf115fd9636e0ae"
            ],
            [
                "7cf115fd9636e0ae"
            ],
            [
                "7cf115fd9636e0ae"
            ],
            [
                "7cf115fd9636e0ae"
            ],
            [
                "7cf115fd9636e0ae"
            ],
            [
                "7cf115fd9636e0ae"
            ],
            [
                "7cf115fd9636e0ae"
            ],
            [],
            [],
            [
                "466ed2c41538986f"
            ],
            [
                "072dac19f53d3a79"
            ],
            [
                "ff862624dc2f2e27"
            ],
            [],
            [
                "1ad3261d0a823ca1"
            ],
            []
        ]
    },
    {
        "id": "7cf115fd9636e0ae",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "2 bytes/valeur : Irritrace, pilowtech, Watermark, sonar, debit",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": msg.payload.uplink_message.decoded_payload.bytes[0],\n    \"value\": ((msg.payload.uplink_message.decoded_payload.bytes[1] * 256) + msg.payload.uplink_message.decoded_payload.bytes[2])\n};\n\n// Vérifie si msg.payload.uplink_message.decoded_payload.bytes[3] existe\nif (msg.payload.uplink_message.decoded_payload.bytes[3] !== undefined) {\n    // Si oui, ajoute la deuxième valeur\n    message.value2 = ((msg.payload.uplink_message.decoded_payload.bytes[3] * 256) + msg.payload.uplink_message.decoded_payload.bytes[4]);\n}\n\n// Vérifie si msg.payload.uplink_message.decoded_payload.bytes[3] existe\nif (msg.payload.uplink_message.decoded_payload.bytes[5] !== undefined) {\n    // Si oui, ajoute la deuxième valeur\n    message.value3 = ((msg.payload.uplink_message.decoded_payload.bytes[5] * 256) + msg.payload.uplink_message.decoded_payload.bytes[6]);\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1600,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "466ed2c41538986f",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "lancelot",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n    \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n    \"battery\": msg.payload.uplink_message.decoded_payload.bytes[0],\n};\nmsg.payload=message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1440,
        "y": 500,
        "wires": [
            [
                "57edebed079741d8"
            ]
        ]
    },
    {
        "id": "d882506b7374bb18",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "msg",
        "func": "var message_connu = {\n    \"chatId\": msg.payload.chatId,\n    \"content\": \"Bonjour !\\n\\nVoici ce que vous pouvez m'envoyer comme commande :\\n\\n- /waterlow : pour connaître l'état de vos waterlow\\n- /porte : pour vérifier l'état de vos portes\\n- /lancelot : pour actionner vos Lancelot\\n\\nN'hésitez pas à me demander ou bien à appuyer directement sur les mots en bleu! \\n\\n Pour info, votre id :  \" + msg.payload.chatId,\n    \"type\": \"message\"\n}\n\nif (msg.payload.chatId == flow.get(\"$parent.chatId\")) \n{\n    msg.payload = message_connu\n    return msg\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1110,
        "y": 40,
        "wires": [
            [
                "c01df125f84d5d12",
                "37db972bbfcf9ce5"
            ]
        ]
    },
    {
        "id": "fbde514cd74df89a",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "msg",
        "func": "if (msg.payload.chatId== flow.get(\"$parent.chatId\")){\n    \n    //msg.payload={}\n    msg.payload.chatId = msg.payload.chatId;\n\n    // Récupérer l'array \"devicesData\" depuis la variable de contexte\n    var devicesData = flow.get(\"$parent.waterlow\");\n    \n    if (Array.isArray(devicesData)) {\n      // Générer le message avec l'état des capteurs\n      var message = \"État des Waterlows :\\n\";\n    \n      devicesData.forEach(function (device) {\n        message += device.name + \" : \" + device.state + \"\\n\";\n      });\n    \n      msg.payload.content = message;\n      return msg;\n    } \n    \n    else {\n      msg.payload.content = \"Aucun Waterlow trouvé !\";\n    }\n    \n    msg.payload.type = \"message\";\n    return msg\n}\nelse {}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1110,
        "y": 80,
        "wires": [
            [
                "c01df125f84d5d12"
            ]
        ]
    },
    {
        "id": "072dac19f53d3a79",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "bme680",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"HR\": msg.payload.uplink_message.decoded_payload[\"HR\"],\n  \"T\": msg.payload.uplink_message.decoded_payload[\"T\"],\n  \"P\": msg.payload.uplink_message.decoded_payload[\"P\"],\n  \"IAQ\": msg.payload.uplink_message.decoded_payload[\"IAQ\"]\n};\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1440,
        "y": 540,
        "wires": [
            []
        ]
    },
    {
        "id": "a6eed9efb6857e84",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "pslb",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {};\n\nif (msg.payload.uplink_message.f_port == 2) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": (msg.payload.uplink_message.decoded_payload.bytes[0]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[1],\n        \"model\": (msg.payload.uplink_message.decoded_payload.bytes[2]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[3],\n        \"value\": (msg.payload.uplink_message.decoded_payload.bytes[4]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[5],\n        \"value2\": (msg.payload.uplink_message.decoded_payload.bytes[6]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[7],\n        \"value3\": (msg.payload.uplink_message.decoded_payload.bytes[8])\n    };\n}\n\nif (msg.payload.uplink_message.f_port == 5) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": (msg.payload.uplink_message.decoded_payload.bytes[5]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[6]\n    };\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 760,
        "wires": [
            []
        ]
    },
    {
        "id": "d05efb5b7e88c5cf",
        "type": "switch",
        "z": "02a9741c1b0f658d",
        "name": "Dragino Interface",
        "property": "ttnData.name",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "pslb",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "ps-lb",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "sn50",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 450,
        "y": 740,
        "wires": [
            [
                "a6eed9efb6857e84"
            ],
            [
                "a6eed9efb6857e84"
            ],
            [
                "23bf8a938d1041cc"
            ]
        ]
    },
    {
        "id": "cbbe7cfe0d249461",
        "type": "switch",
        "z": "02a9741c1b0f658d",
        "name": "Dragino sensor",
        "property": "payload.end_device_ids.device_id",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "tracker",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lwl02",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lds02",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lht52",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lht65",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "dds45",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "dds75",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lds12",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "llds12",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "aiso1",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "ais01",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lms01",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "s31",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "cpl03",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "aqs01",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "dds20",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 16,
        "x": 1220,
        "y": 960,
        "wires": [
            [
                "9f02a09a2e9b82b8"
            ],
            [
                "57b34ac061dcd8cd"
            ],
            [
                "6917685693f377ad"
            ],
            [
                "c1bc9dd95075f976"
            ],
            [
                "961c56582072d30d"
            ],
            [
                "edb77635d5904b5b"
            ],
            [
                "1a74613863d89b42"
            ],
            [
                "c7a7178e9cd35446"
            ],
            [
                "c7a7178e9cd35446"
            ],
            [],
            [
                "d539b183fa9ccd98",
                "a68eb2e723dbd41a"
            ],
            [
                "3c949d7a07afb7d7"
            ],
            [
                "9a96613aa79f5570"
            ],
            [
                "e266fa93e1a43d7b"
            ],
            [
                "eb47cf03b4cc2493"
            ],
            [
                "edb77635d5904b5b"
            ]
        ]
    },
    {
        "id": "9f02a09a2e9b82b8",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "trackerD",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {}\n\nif (msg.payload.uplink_message.f_port==2) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"humidity\": msg.payload.uplink_message.decoded_payload[\"Hum\"],\n        \"temperature\": msg.payload.uplink_message.decoded_payload[\"Tem\"],\n        \"latitude\": msg.payload.uplink_message.decoded_payload[\"Latitude\"],\n        \"longitude\": msg.payload.uplink_message.decoded_payload[\"Longitude\"]\n     };\n}\n\nif (msg.payload.uplink_message.f_port == 5) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": msg.payload.uplink_message.decoded_payload[\"BatV\"],\n    };\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1440,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "6917685693f377ad",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "lds02",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"battery\": msg.payload.uplink_message.decoded_payload[\"BAT_V\"],\n  \"value\": msg.payload.uplink_message.decoded_payload[\"DOOR_OPEN_STATUS\"]\n};\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 960,
        "wires": [
            [
                "fa30b0a0e8cda544"
            ]
        ]
    },
    {
        "id": "c1bc9dd95075f976",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "lht52",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {}\n\nif (msg.payload.uplink_message.f_port==2) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"humidity\": msg.payload.uplink_message.decoded_payload[\"Hum_SHT\"],\n        \"temperature\": msg.payload.uplink_message.decoded_payload[\"TempC_SHT\"],\n        \"temperature_sonde\": msg.payload.uplink_message.decoded_payload[\"TempC_DS\"]\n     };\n}\n\nif (msg.payload.uplink_message.f_port == 5) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": msg.payload.uplink_message.decoded_payload[\"Bat_mV\"],\n   };\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 1000,
        "wires": [
            []
        ]
    },
    {
        "id": "961c56582072d30d",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "lht65",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {}\n\nif (msg.payload.uplink_message.f_port==2) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"humidity\": msg.payload.uplink_message.decoded_payload[\"Hum_SHT\"],\n        \"temperature\": msg.payload.uplink_message.decoded_payload[\"TempC_SHT\"],\n        \"battery\": msg.payload.uplink_message.decoded_payload[\"BatV\"],\n        \"temperature_sonde\": msg.payload.uplink_message.decoded_payload[\"TempC_DS\"]\n     };\n}\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 1040,
        "wires": [
            []
        ]
    },
    {
        "id": "edb77635d5904b5b",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "dds45 (ultrason)",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar distanceStr = msg.payload.uplink_message.decoded_payload[\"Distance\"];\nvar distance = parseInt(distanceStr, 10); // Convertit \"1200mm\" en 1200\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"value\": distance,\n  \"battery\": msg.payload.uplink_message.decoded_payload[\"Bat\"],\n  \"tempC\": msg.payload.uplink_message.decoded_payload[\"TempC_DS18B20\"]\n};\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1460,
        "y": 1080,
        "wires": [
            []
        ]
    },
    {
        "id": "1a74613863d89b42",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "dds75 (ultrason)",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar distanceStr = msg.payload.uplink_message.decoded_payload[\"Distance\"];\nvar distance = parseInt(distanceStr, 10); // Convertit \"1200cm\" en 1200\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"value\": msg.payload.uplink_message.decoded_payload[\"value\"],\n};\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1460,
        "y": 1120,
        "wires": [
            []
        ]
    },
    {
        "id": "c7a7178e9cd35446",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "lds (lidar)",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"value\": msg.payload.uplink_message.decoded_payload[\"Lidar_distance\"],\n  \"battery\": msg.payload.uplink_message.decoded_payload[\"Bat\"],\n  \"temp\": msg.payload.uplink_message.decoded_payload[\"Lidar_temp\"]\n};\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1440,
        "y": 1160,
        "wires": [
            []
        ]
    },
    {
        "id": "d539b183fa9ccd98",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "d": true,
        "name": "ais01",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": ((msg.payload.uplink_message.decoded_payload.bytes[0] << 8) | msg.payload.uplink_message.decoded_payload.bytes[1]),\n    \"value\": (\n        ((msg.payload.uplink_message.decoded_payload.bytes[6] << 24) |\n            (msg.payload.uplink_message.decoded_payload.bytes[7] << 16) |\n            (msg.payload.uplink_message.decoded_payload.bytes[8] << 8) |\n            msg.payload.uplink_message.decoded_payload.bytes[9]) +\n        ((msg.payload.uplink_message.decoded_payload.bytes[10] << 24) |\n            (msg.payload.uplink_message.decoded_payload.bytes[11] << 16) |\n            (msg.payload.uplink_message.decoded_payload.bytes[12] << 8) |\n            msg.payload.uplink_message.decoded_payload.bytes[13]) / Math.pow(10, 8)\n    )\n};\n\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 1200,
        "wires": [
            []
        ]
    },
    {
        "id": "57b34ac061dcd8cd",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "lwl02",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": msg.payload.uplink_message.decoded_payload[\"BAT_V\"],\n        \"value\": msg.payload.uplink_message.decoded_payload[\"WATER_LEAK_STATUS\"]\n    };\nmsg.payload=message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 920,
        "wires": [
            [
                "22bca8a46c5c51ec"
            ]
        ]
    },
    {
        "id": "22bca8a46c5c51ec",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "Alerte lwl02",
        "func": "var devicesData = flow.get(\"$parent.waterlow\");\nvar msg2 = msg.payload;\nvar oldValue ;\nvar alerte = \"\";\n\n// Vérifier si l'array existe déjà dans le contexte\nif (!devicesData) {\n  devicesData = []; // Si l'array n'existe pas, initialisez-le avec un array vide\n}\n\n\n// Rechercher l'index de l'élément correspondant au \"capteur 2\" dans l'array\nvar capteurIndex = devicesData.findIndex(function (device) {\n  return device.name === msg2.name;\n});\n\n// Vérifier si l'élément \"capteur 2\" a été trouvé\nif (capteurIndex !== -1) {\n\n    oldValue = devicesData[capteurIndex].state;\n    // Le \"capteur\" existe dans l'array, mettez à jour son état\n    devicesData[capteurIndex].state = msg2.value;\n    \n} else {\n  // Le \"capteur\" n'existe pas dans l'array, donc nous allons le créer\n  var nouveauCapteur = {\n    \"name\": msg2.name,\n    \"state\": msg2.value}\n  ;\n  devicesData.push(nouveauCapteur);\n}\n\n// Fonction de comparaison pour trier par ordre alphabétique des noms\nfunction compareName(a, b) {\n  var nameA = a.name.toLowerCase();\n  var nameB = b.name.toLowerCase();\n  if (nameA < nameB) return -1;\n  if (nameA > nameB) return 1;\n  return 0;\n}\n\n// Trier l'array par ordre alphabétique des noms des capteurs en utilisant la fonction de comparaison\ndevicesData.sort(compareName);\n\n// Enregistrer à nouveau l'array trié dans la variable de contexte \"devicesData\"\nflow.set(\"$parent.waterlow\", devicesData);\n\n// Envoi alerte si l'état a changé\nmsg.telegram={};\n\nif (oldValue != msg.payload.value){\n    oldValue = msg.payload.value;\n    msg.telegram.payload={}\n    msg.telegram.payload.chatId = flow.get(\"$parent.chatId\");\n    msg.telegram.payload.content = \"le \" + msg2.name + \" passe en \" + msg2.value ;\n    msg.telegram.payload.type = \"message\";\n    return msg.telegram;\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1590,
        "y": 920,
        "wires": [
            []
        ]
    },
    {
        "id": "fa30b0a0e8cda544",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "Alerte lds02",
        "func": "var devicesData = flow.get(\"$parent.porte\");\nvar msg2 = msg.payload;\nvar oldValue;\nvar alerte = \"\";\n\n// Vérifier si l'array existe déjà dans le contexte\nif (!devicesData) {\n  devicesData = []; // Si l'array n'existe pas, initialisez-le avec un array vide\n}\n\n\n// Rechercher l'index de l'élément correspondant au \"capteur 2\" dans l'array\nvar capteurIndex = devicesData.findIndex(function (device) {\n  return device.name === msg2.name;\n});\n\n// Vérifier si l'élément \"capteur 2\" a été trouvé\nif (capteurIndex !== -1) {\n\n  oldValue = devicesData[capteurIndex].state;\n  // Le \"capteur\" existe dans l'array, mettez à jour son état\n  devicesData[capteurIndex].state = msg2.value;\n\n} else {\n  // Le \"capteur\" n'existe pas dans l'array, donc nous allons le créer\n  var nouveauCapteur = {\n    \"name\": msg2.name,\n    \"state\": msg2.value,\n    \"power\": msg2.power\n  }\n    ;\n  devicesData.push(nouveauCapteur);\n}\n\n// Fonction de comparaison pour trier par ordre alphabétique des noms\nfunction compareName(a, b) {\n  var nameA = a.name.toLowerCase();\n  var nameB = b.name.toLowerCase();\n  if (nameA < nameB) return -1;\n  if (nameA > nameB) return 1;\n  return 0;\n}\n\n// Trier l'array par ordre alphabétique des noms des capteurs en utilisant la fonction de comparaison\ndevicesData.sort(compareName);\n\n// Enregistrer à nouveau l'array trié dans la variable de contexte \"devicesData\"\nflow.set(\"$parent.porte\", devicesData);\n\n// Envoi alerte si l'état a changé\nmsg.telegram = {};\n\nif (oldValue != msg.payload.value) {\n  oldValue = msg.payload.value;\n  msg.telegram.payload = {}\n  msg.telegram.payload.chatId = flow.get(\"$parent.chatId\");\n  msg.telegram.payload.content = \"la \" + msg2.name + \" passe en \" + msg2.value;\n  msg.telegram.payload.type = \"message\";\n  return msg.telegram;\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1590,
        "y": 960,
        "wires": [
            []
        ]
    },
    {
        "id": "10bdbc9c0b7e8936",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "msg",
        "func": "if (msg.payload.chatId== flow.get(\"$parent.chatId\")){\n    \n    //msg.payload={}\n    msg.payload.chatId = msg.payload.chatId;\n\n    // Récupérer l'array \"devicesData\" depuis la variable de contexte\n    var devicesData = flow.get(\"$parent.porte\");\n    \n    if (Array.isArray(devicesData)) {\n      // Générer le message avec l'état des capteurs\n      var message = \"État des portes :\\n\";\n    \n      devicesData.forEach(function (device) {\n        message += device.name + \" : \" + device.state + \"\\n\";\n      });\n    \n      msg.payload.content = message;\n      return msg;\n    } \n    \n    else {\n      msg.payload.content = \"Aucune porte trouvé !\";\n    }\n    \n    msg.payload.type = \"message\";\n    return msg\n}\nelse {}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1110,
        "y": 120,
        "wires": [
            [
                "c01df125f84d5d12"
            ]
        ]
    },
    {
        "id": "57edebed079741d8",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "gestion_lancelot",
        "func": "var devicesData = flow.get(\"$parent.lancelot\");\nvar msg2 = msg.payload;\nmsg2.value=0;\nvar oldValue ;\nvar alerte = \"\";\n\n// Vérifier si l'array existe déjà dans le contexte\nif (!devicesData) {\n  devicesData = []; // Si l'array n'existe pas, initialisez-le avec un array vide\n}\n\n\n// Rechercher l'index de l'élément correspondant au \"capteur 2\" dans l'array\nvar capteurIndex = devicesData.findIndex(function (device) {\n  return device.name === msg2.name;\n});\n\n// Vérifier si l'élément \"capteur 2\" a été trouvé\nif (capteurIndex !== -1) {\n\n    oldValue = devicesData[capteurIndex].state;\n    // Le \"capteur\" existe dans l'array, mettez à jour son état\n    devicesData[capteurIndex].state = msg2.value;\n    \n} else {\n  // Le \"capteur\" n'existe pas dans l'array, donc nous allons le créer\n  var nouveauCapteur = {\n    \"name\": msg2.name,\n    \"state\": msg2.value}\n  ;\n  devicesData.push(nouveauCapteur);\n}\n\n// Fonction de comparaison pour trier par ordre alphabétique des noms\nfunction compareName(a, b) {\n  var nameA = a.name.toLowerCase();\n  var nameB = b.name.toLowerCase();\n  if (nameA < nameB) return -1;\n  if (nameA > nameB) return 1;\n  return 0;\n}\n\n// Trier l'array par ordre alphabétique des noms des capteurs en utilisant la fonction de comparaison\ndevicesData.sort(compareName);\n\n// Enregistrer à nouveau l'array trié dans la variable de contexte \"devicesData\"\nflow.set(\"$parent.lancelot\", devicesData);\n\n// Envoi alerte si l'état a changé\nmsg.telegram={};\n\nif (oldValue != msg.payload.value){\n    oldValue = msg.payload.value;\n    msg.telegram.payload={}\n    msg.telegram.payload.chatId = flow.get(\"$parent.chatId\");\n    msg.telegram.payload.content = \"le \" + msg2.name + \" passe en \" + msg2.value ;\n    msg.telegram.payload.type = \"message\";\n    return msg.telegram;\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1660,
        "y": 500,
        "wires": [
            []
        ]
    },
    {
        "id": "3c949d7a07afb7d7",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "lms01",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": ((msg.payload.uplink_message.decoded_payload.bytes[0] << 8) | msg.payload.uplink_message.decoded_payload.bytes[1]),\n    \"value\": ((msg.payload.uplink_message.decoded_payload.bytes[2] << 8) | msg.payload.uplink_message.decoded_payload.bytes[3]),\n    \"value2\": ((msg.payload.uplink_message.decoded_payload.bytes[4] << 8) | msg.payload.uplink_message.decoded_payload.bytes[5]),\n    \"value3\": ((msg.payload.uplink_message.decoded_payload.bytes[6] << 8) | msg.payload.uplink_message.decoded_payload.bytes[7]),\n};\n\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 1240,
        "wires": [
            []
        ]
    },
    {
        "id": "23bf8a938d1041cc",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "sn50v3",
        "func": "// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": 1,\n    \"snr\": 1,\n    \"battery\": (msg.payload.uplink_message.decoded_payload.bytes[11]),\n    \"value\": (msg.payload.uplink_message.decoded_payload.bytes[0]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[1],\n    \"value2\": (msg.payload.uplink_message.decoded_payload.bytes[2]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[3],\n    \"value3\": (msg.payload.uplink_message.decoded_payload.bytes[4]) << 8 | msg.payload.uplink_message.decoded_payload.bytes[5],\n};\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "ff862624dc2f2e27",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "furgo",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": msg.payload.uplink_message.decoded_payload[\"BatV\"],\n    \"value\": (msg.payload.uplink_message.decoded_payload[\"ADC1_V\"])\n};\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "9a96613aa79f5570",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "s31",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": msg.payload.uplink_message.decoded_payload[\"BatV\"],\n    \"temperature\": msg.payload.uplink_message.decoded_payload[\"TempC_SHT\"],\n    \"humidity\": msg.payload.uplink_message.decoded_payload[\"Hum_SHT\"]\n};\n\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 1280,
        "wires": [
            []
        ]
    },
    {
        "id": "37db972bbfcf9ce5",
        "type": "debug",
        "z": "02a9741c1b0f658d",
        "name": "debug 12",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1270,
        "y": 20,
        "wires": []
    },
    {
        "id": "e266fa93e1a43d7b",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "cpl03",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": 0,\n    \"value\": (msg.payload.uplink_message.decoded_payload.bytes[0])\n};\n\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 1320,
        "wires": [
            [
                "954d067c035096ee",
                "a963e0b9bd07d9e3"
            ]
        ]
    },
    {
        "id": "954d067c035096ee",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "Alerte cpl03",
        "func": "var devicesData = flow.get(\"$parent.cpl03\");\nvar msg2 = msg.payload;\nvar oldValue ;\nvar alerte = \"\";\n\n// Vérifier si l'array existe déjà dans le contexte\nif (!devicesData) {\n  devicesData = []; // Si l'array n'existe pas, initialisez-le avec un array vide\n}\n\n\n// Rechercher l'index de l'élément correspondant au \"capteur 2\" dans l'array\nvar capteurIndex = devicesData.findIndex(function (device) {\n  return device.name === msg2.name;\n});\n\n// Vérifier si l'élément \"capteur 2\" a été trouvé\nif (capteurIndex !== -1) {\n\n    oldValue = devicesData[capteurIndex].state;\n    // Le \"capteur\" existe dans l'array, mettez à jour son état\n    devicesData[capteurIndex].state = msg2.value;\n    \n} else {\n  // Le \"capteur\" n'existe pas dans l'array, donc nous allons le créer\n  var nouveauCapteur = {\n    \"name\": msg2.name,\n    \"state\": msg2.value}\n  ;\n  devicesData.push(nouveauCapteur);\n}\n\n// Fonction de comparaison pour trier par ordre alphabétique des noms\nfunction compareName(a, b) {\n  var nameA = a.name.toLowerCase();\n  var nameB = b.name.toLowerCase();\n  if (nameA < nameB) return -1;\n  if (nameA > nameB) return 1;\n  return 0;\n}\n\n// Trier l'array par ordre alphabétique des noms des capteurs en utilisant la fonction de comparaison\ndevicesData.sort(compareName);\n\n// Enregistrer à nouveau l'array trié dans la variable de contexte \"devicesData\"\nflow.set(\"$parent.cpl03\", devicesData);\n\n// Envoi alerte si l'état a changé\nmsg.telegram={};\n\nif (oldValue != msg.payload.value){\n    oldValue = msg.payload.value;\n    msg.telegram.payload={}\n    msg.telegram.payload.chatId = flow.get(\"$parent.chatId\");\n    msg.telegram.payload.content = \"le \" + msg2.name + \" passe en \" + msg2.value ;\n    msg.telegram.payload.type = \"message\";\n    return msg.telegram;\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1590,
        "y": 1320,
        "wires": [
            []
        ]
    },
    {
        "id": "a963e0b9bd07d9e3",
        "type": "debug",
        "z": "02a9741c1b0f658d",
        "name": "debug 14",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1570,
        "y": 1360,
        "wires": []
    },
    {
        "id": "a68eb2e723dbd41a",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "ais01",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar bytes = msg.payload.uplink_message.decoded_payload.bytes;\n\n// Reconstituer la partie entière (bytes 6 à 9) — 4 octets\n// On combine les 4 octets en un entier 32 bits (big endian)\nvar integerPart = (bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9];\n\n// Reconstituer la partie décimale (bytes 10 à 13) — 4 octets\nvar decimalPart = (bytes[10] << 24) | (bytes[11] << 16) | (bytes[12] << 8) | bytes[13];\n\n// Pour éviter les problèmes liés au bit de signe lors du décalage à gauche (car JS utilise 32 bits signés)\n// Convertir en unsigned via >>> 0 :\nintegerPart = integerPart >>> 0;\ndecimalPart = decimalPart >>> 0;\n\n// Calculer la valeur finale (en considérant que la partie décimale est divisée par 10^n)\n// Ici on suppose que la partie décimale représente des chiffres après la virgule, par exemple 4 chiffres, donc division par 10000\nvar value = integerPart + (decimalPart / 10000);\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": ((msg.payload.uplink_message.decoded_payload.bytes[0] << 8) | msg.payload.uplink_message.decoded_payload.bytes[1]),\n    \"value\":value,\n    \"byte6\": bytes[6],\n    \"byte7\": bytes[7],\n    \"byte8\": bytes[8],\n    \"byte9\": bytes[9],\n    \"byte10\": bytes[10],\n    \"byte11\": bytes[11],\n    \"byte12\": bytes[12],\n    \"byte13\": bytes[13]\n};\n\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 1360,
        "wires": [
            []
        ]
    },
    {
        "id": "1ad3261d0a823ca1",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "davele",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\n// Construire le message avec les valeurs maximales de RSSI et SNR\nvar message = {\n    \"name\": msg.payload.end_device_ids.device_id,\n    \"rssi\": maxRSSI,\n    \"snr\": maxSNR,\n    \"battery\": msg.payload.uplink_message.decoded_payload.bytes[0],\n    \"distance\": ((msg.payload.uplink_message.decoded_payload.bytes[1] * 256) + msg.payload.uplink_message.decoded_payload.bytes[2]),\n    \"bpm\": msg.payload.uplink_message.decoded_payload.bytes[3],\n    \"lux\": msg.payload.uplink_message.decoded_payload.bytes[4]\n};\n\n// Vérifie si msg.payload.uplink_message.decoded_payload.bytes[3] existe\nif (msg.payload.uplink_message.decoded_payload.bytes[3] !== undefined) {\n    // Si oui, ajoute la deuxième valeur\n    message.value2 = ((msg.payload.uplink_message.decoded_payload.bytes[3] * 256) + msg.payload.uplink_message.decoded_payload.bytes[4]);\n}\n\n// Vérifie si msg.payload.uplink_message.decoded_payload.bytes[3] existe\nif (msg.payload.uplink_message.decoded_payload.bytes[5] !== undefined) {\n    // Si oui, ajoute la deuxième valeur\n    message.value3 = ((msg.payload.uplink_message.decoded_payload.bytes[5] * 256) + msg.payload.uplink_message.decoded_payload.bytes[6]);\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "eb47cf03b4cc2493",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "aqs01",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n    var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n    var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n    // Mettre à jour les valeurs maximales si nécessaire\n    if (currentRSSI > maxRSSI) {\n        maxRSSI = currentRSSI;\n    }\n\n    if (currentSNR > maxSNR) {\n        maxSNR = currentSNR;\n    }\n}\n\nvar message = {}\n\nif (msg.payload.uplink_message.f_port==2) {\n    message = {\n        \"name\": msg.payload.end_device_ids.device_id,\n        \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n        \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n        \"battery\": ((msg.payload.uplink_message.decoded_payload.bytes[0] << 8) | msg.payload.uplink_message.decoded_payload.bytes[1]),\n        \"temperature\": ((msg.payload.uplink_message.decoded_payload.bytes[2] << 8) | msg.payload.uplink_message.decoded_payload.bytes[3]),\n        \"humidity\": ((msg.payload.uplink_message.decoded_payload.bytes[4] << 8) | msg.payload.uplink_message.decoded_payload.bytes[5]),\n        \"pressure\": ((msg.payload.uplink_message.decoded_payload.bytes[6] << 8) | msg.payload.uplink_message.decoded_payload.bytes[7]),\n        \"co2\": ((msg.payload.uplink_message.decoded_payload.bytes[8] << 8) | msg.payload.uplink_message.decoded_payload.bytes[9])\n     };\n}\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 1400,
        "wires": [
            []
        ]
    },
    {
        "id": "f3fb07f82eb32d49",
        "type": "switch",
        "z": "02a9741c1b0f658d",
        "name": "milesight Interface",
        "property": "payload.end_device_ids.device_id",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "em300",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1110,
        "y": 1400,
        "wires": [
            [
                "bb7445c96d150cda"
            ]
        ]
    },
    {
        "id": "bb7445c96d150cda",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "em300",
        "func": "var maxRSSI = msg.payload.uplink_message.rx_metadata[0].rssi;\nvar maxSNR = msg.payload.uplink_message.rx_metadata[0].snr;\n\n// Parcourir tous les éléments de rx_metadata pour trouver les valeurs maximales de RSSI et SNR\nfor (var i = 1; i < msg.payload.uplink_message.rx_metadata.length; i++) {\n  var currentRSSI = msg.payload.uplink_message.rx_metadata[i].rssi;\n  var currentSNR = msg.payload.uplink_message.rx_metadata[i].snr;\n\n  // Mettre à jour les valeurs maximales si nécessaire\n  if (currentRSSI > maxRSSI) {\n    maxRSSI = currentRSSI;\n  }\n\n  if (currentSNR > maxSNR) {\n    maxSNR = currentSNR;\n  }\n}\n\nvar message = {\n  \"name\": msg.payload.end_device_ids.device_id,\n  \"rssi\": msg.payload.uplink_message.rx_metadata[0].rssi,\n  \"snr\": msg.payload.uplink_message.rx_metadata[0].snr,\n  \"humidity\": msg.payload.uplink_message.decoded_payload[\"humidity\"],\n  \"battery\": msg.payload.uplink_message.decoded_payload[\"battery\"],\n  \"temperature\": msg.payload.uplink_message.decoded_payload[\"temperature\"]\n};\n\nmsg.payload = message;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1310,
        "y": 1400,
        "wires": [
            []
        ]
    },
    {
        "id": "7489152045c5d7ce",
        "type": "telegram command",
        "z": "02a9741c1b0f658d",
        "d": true,
        "name": "hello",
        "command": "/hello",
        "description": "",
        "registercommand": false,
        "language": "",
        "scope": "default",
        "bot": "36f1cf07c6e6ca84",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 970,
        "y": 40,
        "wires": [
            [
                "d882506b7374bb18",
                "37db972bbfcf9ce5"
            ],
            []
        ]
    },
    {
        "id": "68ae1945c1161f3d",
        "type": "telegram command",
        "z": "02a9741c1b0f658d",
        "d": true,
        "name": "Waterlow",
        "command": "/waterlow",
        "description": "",
        "registercommand": false,
        "language": "",
        "scope": "default",
        "bot": "36f1cf07c6e6ca84",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 980,
        "y": 80,
        "wires": [
            [
                "fbde514cd74df89a"
            ],
            []
        ]
    },
    {
        "id": "5eda8f14f4d92ac3",
        "type": "telegram command",
        "z": "02a9741c1b0f658d",
        "d": true,
        "name": "Portes",
        "command": "/porte",
        "description": "",
        "registercommand": false,
        "language": "",
        "scope": "default",
        "bot": "36f1cf07c6e6ca84",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 970,
        "y": 120,
        "wires": [
            [
                "10bdbc9c0b7e8936"
            ],
            []
        ]
    },
    {
        "id": "c01df125f84d5d12",
        "type": "telegram sender",
        "z": "02a9741c1b0f658d",
        "d": true,
        "name": "Send msg",
        "bot": "36f1cf07c6e6ca84",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1260,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "68b5bdab613bea44",
        "type": "inject",
        "z": "02a9741c1b0f658d",
        "name": "change chatID",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "chatID",
                "v": "-4215540322",
                "vt": "num"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "mobilab-truck",
        "payloadType": "str",
        "x": 550,
        "y": 20,
        "wires": [
            [
                "3f65e47bc3a669df"
            ]
        ]
    },
    {
        "id": "3f65e47bc3a669df",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "chatID Update",
        "func": "// --- Récupération du contexte existant ---\nlet apps = flow.get(\"apps\", \"file\") || {};\n\n// --- Lecture des entrées ---\nlet appID = msg.payload;\nlet chatID = msg.chatID;\n\n// --- Changement de chatID ---\napps[appID].chatID = chatID;\n\n// --- Sauvegarde dans le contexte persistant ---\nflow.set(\"apps\", apps, \"file\");\n\n// --- Optionnel : renvoyer l'état complet ---\nmsg.payload = apps[appID];\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "02586fa4c16be55a",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "extractData",
        "func": "// Récupération du payload principal\nlet p = msg?.payload;\n\n// Vérifie la présence minimale d'un device ID\nif (!p.end_device_ids.device_id) {\n    node.warn(\"⚠️ Device ID manquant dans le message TTN\");\n    return null;\n}\n\n// Récupération du decoded_payload existant (TTN), sinon null\nlet decoded = p.uplink_message.decoded_payload ?? null;\n\n// Si pas de decoded_payload → on génère un fallback depuis frm_payload\nif (!decoded) {\n    const b64 = p.uplink_message.frm_payload;\n\n    if (!b64) {\n        node.warn(\"⚠️ Aucun decoded_payload et aucun frm_payload présent\");\n    } else {\n        const raw = Buffer.from(b64, \"base64\");\n        decoded = {\n            bytes: Array.from(raw),\n            length: raw.length,\n            hex: raw.toString(\"hex\")\n        };\n    }\n}\n\n// Récupère les métadonnées radio (si dispo)\nlet rx_metadata = p.uplink_message.rx_metadata || [];\n\n// Valeurs par défaut\nlet maxRSSI = rx_metadata?.[0]?.rssi ?? null;\nlet maxSNR  = rx_metadata?.[0]?.snr  ?? null;\n\n// Parcours pour trouver les valeurs maximales\nfor (let i = 1; i < (rx_metadata.length); i++) {\n    let m = rx_metadata[i];\n    if (m.rssi > maxRSSI) maxRSSI = m.rssi;\n    if (m.snr  > maxSNR)  maxSNR  = m.snr;\n}\n\n// Construit un message propre et résilient\nlet message = {\n    name: p.end_device_ids.device_id,\n    app: p.end_device_ids.application_ids.application_id,\n    lastUpdate: p.received_at,\n    rssi: maxRSSI,\n    snr: maxSNR,\n    decoded_payload: decoded\n};\n\n// Renvoie un message simplifié\nmsg.ttnData = message;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 520,
        "wires": [
            [
                "5bef962b4a019b89",
                "9a95773a555b35d4",
                "785006319e31835e",
                "4248ff97f907509c",
                "d05efb5b7e88c5cf"
            ]
        ]
    },
    {
        "id": "de175e6d845d0b43",
        "type": "inject",
        "z": "02a9741c1b0f658d",
        "name": "porte 1",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"end_device_ids\":{\"device_id\":\"porte-01\",\"application_ids\":{\"application_id\":\"mobilab-truck\"},\"dev_eui\":\"70B3D57ED0072D6C\",\"join_eui\":\"0000000000000000\",\"dev_addr\":\"260B7E4E\"},\"correlation_ids\":[\"gs:uplink:01K71FCN0MB0BA21P7D3NQ1TSW\"],\"received_at\":\"2025-10-08T08:35:47.556876883Z\",\"uplink_message\":{\"session_key_id\":\"AZl2rHHCAzLVJCH6gefqcg==\",\"f_port\":1,\"f_cnt\":18339,\"frm_payload\":\"AC4ANgHxABgAMiRO\",\"decoded_payload\":{\"LAST_WATER_LEAK_DURATION\":0,\"MOD\":2,\"DOOR_OPEN_STATUS\":1,\"WATER_LEAK_TIMES\":0},\"rx_metadata\":[{\"gateway_ids\":{\"gateway_id\":\"lisah-ug65-1\",\"eui\":\"24E124FFFEF7E3D6\"},\"time\":\"2025-10-08T08:35:47.328Z\",\"timestamp\":403505293,\"rssi\":-82,\"channel_rssi\":-82,\"snr\":13.5,\"frequency_offset\":\"230\",\"location\":{\"latitude\":43.61944841808217,\"longitude\":3.857522711001851,\"altitude\":80,\"source\":\"SOURCE_REGISTRY\"},\"uplink_token\":\"ChoKGAoMbGlzYWgtdWc2NS0xEggk4ST//vfj1hCNgbTAARoMCOPEmMcGELDDl6YBIMjNqJbfkekGKgwI48SYxwYQgMSznAE=\",\"channel_index\":3,\"gps_time\":\"2025-10-08T08:35:47.328Z\",\"received_at\":\"2025-10-08T08:35:47.330007620Z\"}],\"settings\":{\"data_rate\":{\"lora\":{\"bandwidth\":125000,\"spreading_factor\":7,\"coding_rate\":\"4/5\"}},\"frequency\":\"867100000\",\"timestamp\":403505293,\"time\":\"2025-10-08T08:35:47.328Z\"},\"received_at\":\"2025-10-08T08:35:47.349656096Z\",\"consumed_airtime\":\"0.061696s\",\"packet_error_rate\":0.04761905,\"network_ids\":{\"net_id\":\"000013\",\"ns_id\":\"EC656E0000000181\",\"tenant_id\":\"ttn\",\"cluster_id\":\"eu1\",\"cluster_address\":\"eu1.cloud.thethings.network\"}}}",
        "payloadType": "json",
        "x": 110,
        "y": 440,
        "wires": [
            [
                "02586fa4c16be55a"
            ]
        ]
    },
    {
        "id": "408daea068a13eaa",
        "type": "inject",
        "z": "02a9741c1b0f658d",
        "name": "porte 0",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"end_device_ids\":{\"device_id\":\"porte-01\",\"application_ids\":{\"application_id\":\"mobilab-truck\"},\"dev_eui\":\"70B3D57ED0072D6C\",\"join_eui\":\"0000000000000000\",\"dev_addr\":\"260B7E4E\"},\"correlation_ids\":[\"gs:uplink:01K71FCN0MB0BA21P7D3NQ1TSW\"],\"received_at\":\"2025-10-08T08:35:47.556876883Z\",\"uplink_message\":{\"session_key_id\":\"AZl2rHHCAzLVJCH6gefqcg==\",\"f_port\":1,\"f_cnt\":18339,\"frm_payload\":\"AC4ANgHxABgAMiRO\",\"decoded_payload\":{\"BAT_V\":2.742,\"LAST_WATER_LEAK_DURATION\":0,\"MOD\":2,\"DOOR_OPEN_STATUS\":0,\"WATER_LEAK_TIMES\":0},\"rx_metadata\":[{\"gateway_ids\":{\"gateway_id\":\"lisah-ug65-1\",\"eui\":\"24E124FFFEF7E3D6\"},\"time\":\"2025-10-08T08:35:47.328Z\",\"timestamp\":403505293,\"rssi\":-82,\"channel_rssi\":-82,\"snr\":13.5,\"frequency_offset\":\"230\",\"location\":{\"latitude\":43.61944841808217,\"longitude\":3.857522711001851,\"altitude\":80,\"source\":\"SOURCE_REGISTRY\"},\"uplink_token\":\"ChoKGAoMbGlzYWgtdWc2NS0xEggk4ST//vfj1hCNgbTAARoMCOPEmMcGELDDl6YBIMjNqJbfkekGKgwI48SYxwYQgMSznAE=\",\"channel_index\":3,\"gps_time\":\"2025-10-08T08:35:47.328Z\",\"received_at\":\"2025-10-08T08:35:47.330007620Z\"}],\"settings\":{\"data_rate\":{\"lora\":{\"bandwidth\":125000,\"spreading_factor\":7,\"coding_rate\":\"4/5\"}},\"frequency\":\"867100000\",\"timestamp\":403505293,\"time\":\"2025-10-08T08:35:47.328Z\"},\"received_at\":\"2025-10-08T08:35:47.349656096Z\",\"consumed_airtime\":\"0.061696s\",\"packet_error_rate\":0.04761905,\"network_ids\":{\"net_id\":\"000013\",\"ns_id\":\"EC656E0000000181\",\"tenant_id\":\"ttn\",\"cluster_id\":\"eu1\",\"cluster_address\":\"eu1.cloud.thethings.network\"}}}",
        "payloadType": "json",
        "x": 110,
        "y": 480,
        "wires": [
            [
                "02586fa4c16be55a"
            ]
        ]
    },
    {
        "id": "23837d8d4b17eef7",
        "type": "debug",
        "z": "02a9741c1b0f658d",
        "name": "debug 13",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1640,
        "y": 580,
        "wires": []
    },
    {
        "id": "5bef962b4a019b89",
        "type": "switch",
        "z": "02a9741c1b0f658d",
        "name": "Dragino TOR",
        "property": "ttnData.name",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "lds02",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "porte",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lwl02",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 430,
        "y": 460,
        "wires": [
            [
                "75d533f4b23ef5fc"
            ],
            [
                "75d533f4b23ef5fc"
            ],
            [
                "742d1d0a2caa8a0d"
            ]
        ]
    },
    {
        "id": "eac9a92fd12de9ad",
        "type": "telegram sender",
        "z": "02a9741c1b0f658d",
        "name": "",
        "bot": "389caaaa5d0b8f80",
        "haserroroutput": false,
        "outputs": 1,
        "x": 990,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "cc77ae832c01d71a",
        "type": "inject",
        "z": "02a9741c1b0f658d",
        "name": "change name",
        "props": [
            {
                "p": "appId",
                "v": "mobilab-truck",
                "vt": "str"
            },
            {
                "p": "oldName",
                "v": "porte-01",
                "vt": "str"
            },
            {
                "p": "newName",
                "v": "porte du bas",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 550,
        "y": 60,
        "wires": [
            [
                "f38c19bcb0358ef7"
            ]
        ]
    },
    {
        "id": "f38c19bcb0358ef7",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "nameUpdate",
        "func": "// --- Récupération des infos du message ---\nlet appID   = msg.appId;   // ex: \"mobilab-truck\"\nlet oldName = msg.oldName;   // ex: \"porte-01\"\nlet newName = msg.newName;   // ex: \"porte du bas\"\n\n// --- Récupération du contexte global ---\nlet apps = flow.get(\"apps\", \"file\") || {};\n\n// --- Vérif minimale ---\nif (!appID || !oldName || !newName) {\n    node.warn(\"⚠️ Paramètre manquant (appID, oldName ou newName)\");\n    return null;\n}\n\n// --- Vérifie que l'app et le capteur existent ---\nif (!apps[appID]) {\n    node.warn(`⚠️ Application '${appID}' non trouvée`);\n    return null;\n}\nif (!apps[appID].sensors?.[oldName]) {\n    node.warn(`⚠️ Capteur '${oldName}' non trouvé dans ${appID}`);\n    return null;\n}\n\n// --- Modification du champ \"name\" uniquement ---\napps[appID].sensors[oldName].name = newName;\n\n// --- Sauvegarde dans le contexte ---\nflow.set(\"apps\", apps, \"file\");\n\n// --- Retour d'information ---\nmsg.payload = {\n    success: true,\n    message: `✅ Champ \"name\" du capteur '${oldName}' mis à jour : \"${newName}\"`,\n    updated: apps[appID].sensors[oldName]\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "742d1d0a2caa8a0d",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "lwl02",
        "func": "// --- Contexte global ---\nlet apps = flow.get(\"apps\", \"file\") || {};\n\n// --- Message entrant ---\nlet p = msg?.ttnData || {};\nlet deviceID = p.name;\nlet appID = p.app;\n\n// --- Vérifs minimales ---\nif (!appID || !deviceID) {\n    node.warn(\"Champs manquants (appID/deviceID)\");\n    return msg;\n}\n\nlet newSensor = {\n    name: deviceID,\n    appID: appID,\n    lastUpdate: p.lastUpdate,\n    rssi: p.rssi,\n    snr: p.snr,\n    battery: p.decoded_payload?.BAT_V,\n    value: p.decoded_payload?.WATER_LEAK_STATUS\n};\n\n// --- Si l'application n'existe pas encore, on la crée ---\nif (!apps[appID]) {\n    apps[appID] = { chatID: \"000\", sensors: {} };\n}\n\n// --- Si le capteur n'existe pas encore, on le crée ---\nif (!apps[appID].sensors[deviceID]) {\n    apps[appID].sensors[deviceID] = newSensor;\n    flow.set(\"apps\", apps, \"file\");\n    msg.payload = { info: `${deviceID} créé dans ${appID}` };\n    return msg;\n}\n\n// --- Sinon, capteur existant ---\nlet storedSensor = apps[appID].sensors[deviceID];\nlet oldValue = storedSensor?.value ?? null;\n\n// --- Mise à jour de tous les champs sauf appID et name ---\nfor (let key of Object.keys(newSensor)) {\n    if (key !== \"appID\" && key !== \"name\") {\n        storedSensor[key] = newSensor[key];\n    }\n}\n// --- Sauvegarde ---\nflow.set(\"apps\", apps, \"file\");\n\n// --- Structure pour Postgre ---\nmsg.toStore = { [deviceID]: storedSensor};\n\n// --- Notification Telegram si changement de value ---\nif (oldValue !== null && oldValue !== newSensor.value && newSensor.value !== null) {\n    let chatID = Number(apps[appID].chatID);\n    if (chatID) {\n        msg.payload = {\n            chatId: chatID,\n            type: \"message\",\n            content: `${storedSensor.name} a changé d'état : ${oldValue} → ${newSensor.value}`\n        };\n        return msg; // vers le bot Telegram\n    }\n}\n\n// --- Sinon, passe le message Postgre ---\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 480,
        "wires": [
            [
                "eac9a92fd12de9ad",
                "82959a9032470062"
            ]
        ]
    },
    {
        "id": "9a95773a555b35d4",
        "type": "switch",
        "z": "02a9741c1b0f658d",
        "name": "AutoConstruction",
        "property": "ttnData.name",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "pilowtech",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "irritrace",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "debit",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "sonar",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "watermark",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "latex",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 6,
        "x": 450,
        "y": 560,
        "wires": [
            [
                "90c525082f14d48f",
                "02e61810ed7dfbfc"
            ],
            [
                "90c525082f14d48f"
            ],
            [
                "90c525082f14d48f"
            ],
            [
                "90c525082f14d48f"
            ],
            [
                "90c525082f14d48f"
            ],
            [
                "955002b18169c8a4"
            ]
        ]
    },
    {
        "id": "90c525082f14d48f",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "2bytes/val : Irritrace, pilowtech, Watermark, sonar, debit",
        "func": "// --- Récupération du message simplifié venant du node précédent ---\nlet p = msg?.ttnData;\n\n// --- Extraction des infos principales ---\nlet appID = p.app;\nlet deviceID = p.name;\n\n// --- Décodage du payload brut ---\nlet bytes = p.decoded_payload?.bytes || [];\nlet battery = bytes[0];\nlet value = (bytes[1] * 256) + bytes[2];\nlet value2 = bytes[3] !== undefined ? (bytes[3] * 256) + bytes[4] : undefined;\nlet value3 = bytes[5] !== undefined ? (bytes[5] * 256) + bytes[6] : undefined;\n\n// --- Construction du message simplifié ---\nlet message = {\n    name: deviceID,\n    appID: appID,\n    lastUpdate: p.lastUpdate,\n    rssi: p.rssi,\n    snr: p.snr,\n    battery: battery,\n    value: value,\n    ...(value2 !== undefined && { value2 }),\n    ...(value3 !== undefined && { value3 })\n};\n\n// --- Structure finale pour insertion dans apps ---\nmsg.toStore = {\n    [message.name]: {\n        appID: message.appID,\n        name: message.name,\n        lastUpdate: message.lastUpdate,\n        rssi: message.rssi,\n        snr: message.snr,\n        battery: message.battery,\n        value: message.value,\n        ...(message.value2 !== undefined && { value2: message.value2 }),\n        ...(message.value3 !== undefined && { value3: message.value3 })\n    }\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 560,
        "wires": [
            [
                "d5c1b697eb24f1c5",
                "5a55a1571ee229e1"
            ]
        ]
    },
    {
        "id": "d5c1b697eb24f1c5",
        "type": "debug",
        "z": "02a9741c1b0f658d",
        "name": "toStore",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "toStore",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1160,
        "y": 700,
        "wires": []
    },
    {
        "id": "785006319e31835e",
        "type": "debug",
        "z": "02a9741c1b0f658d",
        "name": "rawData",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "ttnData",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 420,
        "y": 360,
        "wires": []
    },
    {
        "id": "02e61810ed7dfbfc",
        "type": "debug",
        "z": "02a9741c1b0f658d",
        "name": "debug 16",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 520,
        "wires": []
    },
    {
        "id": "4248ff97f907509c",
        "type": "switch",
        "z": "02a9741c1b0f658d",
        "name": "Dragino Sensors",
        "property": "ttnData.name",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "lht52",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 450,
        "y": 640,
        "wires": [
            [
                "7e4675f86311c061",
                "aa3033b88cbc803b"
            ]
        ]
    },
    {
        "id": "7e4675f86311c061",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "lht52",
        "func": "// --- Récupération du message simplifié venant du node précédent ---\nlet p = msg?.ttnData;\n\n// --- Construction du message final pour les portes ---\nlet message = {\n    name: p.name,\n    appID: p.app,\n    lastUpdate: p.lastUpdate,\n    rssi: p.rssi,\n    snr: p.snr,\n    battery: p.decoded_payload?.BAT_V,\n    humidity : p.decoded_payload?.Hum_SHT,\n    temperature : p.decoded_payload?.TempC_SHT,\n    temperature_probe : p.decoded_payload?.TempC_DS\n};\n\n// --- Structure finale pour insertion dans apps ---\nmsg.toStore = {\n    [message.name]: {\n        appID: message.appID,\n        name: message.name,\n        lastUpdate: message.lastUpdate,\n        rssi: message.rssi,\n        snr: message.snr,\n        battery: message.battery,\n        humidity: message.humidity,\n        temperature: message.temperature,\n        temperature_probe: message.temperature_probe\n    },\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 640,
        "wires": [
            [
                "5a55a1571ee229e1"
            ]
        ]
    },
    {
        "id": "5a55a1571ee229e1",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "store Ctxt",
        "func": "// --- Récupération du contexte global ---\nlet apps = flow.get(\"apps\", \"file\") || {};   // stockage persistant dans \"file\"\n\n// --- Lecture du message entrant ---\nlet p = msg.toStore;\nlet deviceID = Object.keys(p)[0]; // ex: \"sonar-01\"\nlet newSensor = p[deviceID];      // ex: { appID:\"chapitre\", name:\"sonar cuve\", ... }\n\n// --- Vérifs minimales ---\nif (!deviceID || !newSensor || !newSensor.appID) {\n    node.warn(\"Champs manquants (deviceID ou appID)\");\n    return null;\n}\n\n// --- Si l'app n'existe pas encore, on la crée ---\nlet appID = newSensor.appID;\nif (!apps[appID]) {\n    apps[appID] = {\n        chatID: \"000\",\n        sensors: {}\n    };\n}\n\n// --- Si le capteur n'existe pas encore, on le crée --- \nif (!apps[appID].sensors[deviceID]) {\n    apps[appID].sensors[deviceID] = newSensor;\n} else {\n    // --- Mise à jour : on conserve appID et name, on met à jour le reste ---\n    let oldSensor = apps[appID].sensors[deviceID];\n    for (let key in newSensor) {\n        if (key !== \"appID\" && key !== \"name\") {\n            oldSensor[key] = newSensor[key];\n        }\n    }\n}\n\n// --- Sauvegarde du contexte ---\nflow.set(\"apps\", apps, \"file\");\n\n// --- Retour du message (facultatif) ---\nmsg.apps = apps;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 600,
        "wires": [
            [
                "b97ac7dd9c613636"
            ]
        ]
    },
    {
        "id": "b97ac7dd9c613636",
        "type": "debug",
        "z": "02a9741c1b0f658d",
        "name": "toStore",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "toStore",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1280,
        "y": 600,
        "wires": []
    },
    {
        "id": "aa3033b88cbc803b",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "trackerD",
        "func": "// --- Récupération du message simplifié venant du node précédent ---\nlet p = msg?.ttnData;\n\n// --- Construction du message final pour les portes ---\nlet message = {\n    name: p.name,\n    appID: p.app,\n    lastUpdate: p.lastUpdate,\n    rssi: p.rssi,\n    snr: p.snr,\n    battery: p.decoded_payload?.Bat_V,\n    temperature : p.decoded_payload?.Tem,\n    humidity: p.decoded_payload?.Hum,\n    latitude : p.decoded_payload?.Latitude,\n    longitude : p.decoded_payload?.Longitude\n};\n\n// --- Structure finale pour insertion dans apps ---\nmsg.toStore = {\n    [message.name]: {\n        appID: message.appID,\n        name: message.name,\n        lastUpdate: message.lastUpdate,\n        rssi: message.rssi,\n        snr: message.snr,\n        battery: message.battery,\n        humidity: message.humidity,\n        temperature: message.temperature,\n        latitude: message.latitude,\n        longitude: message.longitude,\n    },\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 640,
        "y": 680,
        "wires": [
            [
                "d5c1b697eb24f1c5",
                "5a55a1571ee229e1"
            ]
        ]
    },
    {
        "id": "955002b18169c8a4",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "latex",
        "func": "// --- Récupération du message simplifié venant du node précédent ---\nlet p = msg?.ttnData;\n\n// --- Extraction des infos principales ---\nlet appID = p.app;\nlet deviceID = p.name;\n\n// --- Décodage du payload brut ---\nlet bytes = p.decoded_payload?.bytes || [];\n\n// --- Construction du message simplifié ---\nlet message = {\n    name: p.name,\n    appID: p.app,\n    lastUpdate: p.lastUpdate,\n    rssi: p.rssi,\n    snr: p.snr,\n    battery: bytes[11],\n    min: (bytes[0] << 8) + bytes[1],\n    max: (bytes[2] << 8) + bytes[3],\n    mean: ((bytes[4] << 8) + bytes[5]) / 10.0,\n    sd: ((bytes[6] << 8) + bytes[7]) / 10.0, \n    median: ((bytes[8] << 8) + bytes[9]), \n    validCount: bytes[10]\n};\n\n// --- Structure finale pour insertion dans apps ---\nmsg.toStore = {\n    [message.name]: {\n        appID: message.appID,\n        name: message.name,\n        lastUpdate: message.lastUpdate,\n        rssi: message.rssi,\n        snr: message.snr,\n        battery: message.battery,\n        min: message.min,\n        max: message.max,\n        mean: message.mean,\n        sd: message.sd,\n        median: message.median,\n        validCount: message.validCount\n    }\n};\n\nreturn msg;\n\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 600,
        "wires": [
            [
                "5a55a1571ee229e1"
            ]
        ]
    },
    {
        "id": "62c6dc0a5c3047c4",
        "type": "inject",
        "z": "02a9741c1b0f658d",
        "name": "inject",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "00 00 * * *",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 110,
        "y": 20,
        "wires": [
            [
                "7d0e3ab738f6aed4"
            ]
        ]
    },
    {
        "id": "7d0e3ab738f6aed4",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "function 3",
        "func": "let apps = flow.get(\"apps\", \"file\") || {};\n\n// Fonction utilitaire pour trier un objet par clé\nfunction sortObject(obj) {\n    return Object.keys(obj)\n        .sort()\n        .reduce((acc, key) => {\n            acc[key] = obj[key];\n            return acc;\n        }, {});\n}\n\n// Tri des applications\nlet sortedApps = sortObject(apps);\n\n// Tri des capteurs dans chaque application\nfor (let appID in sortedApps) {\n    if (sortedApps[appID].sensors) {\n        sortedApps[appID].sensors = sortObject(sortedApps[appID].sensors);\n    }\n}\n\n// Met à jour le contexte avec la version triée\nflow.set(\"apps\", sortedApps, \"file\");\n\nmsg.payload = sortedApps;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 240,
        "y": 20,
        "wires": [
            [
                "22a5779c6bc15798"
            ]
        ]
    },
    {
        "id": "75d533f4b23ef5fc",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "lds02",
        "func": "// --- Contexte global ---\nlet apps = flow.get(\"apps\", \"file\") || {};\n\n// --- Message entrant ---\nlet p = msg?.ttnData || {};\nlet deviceID = p.name;\nlet appID = p.app;\n\n// --- Vérifs minimales ---\nif (!appID || !deviceID) {\n    node.warn(\"Champs manquants (appID/deviceID)\");\n    return msg;\n}\n\nlet newSensor = {\n    name: deviceID,\n    appID: appID,\n    lastUpdate: p.lastUpdate,\n    rssi: p.rssi,\n    snr: p.snr,\n    battery: p.decoded_payload?.BAT_V,\n    value: p.decoded_payload?.DOOR_OPEN_STATUS\n};\n\n// --- Si l'application n'existe pas encore, on la crée ---\nif (!apps[appID]) {\n    apps[appID] = { chatID: \"000\", sensors: {} };\n}\n\n// --- Si le capteur n'existe pas encore, on le crée ---\nif (!apps[appID].sensors[deviceID]) {\n    apps[appID].sensors[deviceID] = newSensor;\n    flow.set(\"apps\", apps, \"file\");\n    msg.payload = { info: `${deviceID} créé dans ${appID}` };\n    return msg;\n}\n\n// --- Sinon, capteur existant ---\nlet storedSensor = apps[appID].sensors[deviceID];\nlet oldValue = storedSensor?.value ?? null;\n\n// --- Mise à jour de tous les champs sauf appID et name ---\nfor (let key of Object.keys(newSensor)) {\n    if (key !== \"appID\" && key !== \"name\") {\n        storedSensor[key] = newSensor[key];\n    }\n}\n// --- Sauvegarde ---\nflow.set(\"apps\", apps, \"file\");\n\n// --- Structure pour Postgre ---\nmsg.toStore = { [deviceID]: storedSensor};\n\n// --- Notification Telegram si changement de value ---\nif (oldValue !== null && oldValue !== newSensor.value && newSensor.value !== null) {\n    let chatID = Number(apps[appID].chatID);\n    if (chatID) {\n        msg.payload = {\n            chatId: chatID,\n            type: \"message\",\n            content: `${storedSensor.name} a changé d'état : ${oldValue} → ${newSensor.value}`\n        };\n        return msg; // vers le bot Telegram\n    }\n}\n\n// --- Sinon, passe le message Postgre ---\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 440,
        "wires": [
            [
                "eac9a92fd12de9ad",
                "82959a9032470062"
            ]
        ]
    },
    {
        "id": "82959a9032470062",
        "type": "debug",
        "z": "02a9741c1b0f658d",
        "name": "toStore",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 420,
        "wires": []
    },
    {
        "id": "f8a4a4a5022dddd5",
        "type": "inject",
        "z": "02a9741c1b0f658d",
        "name": "lwl02",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"end_device_ids\":{\"device_id\":\"lwl02-01\",\"application_ids\":{\"application_id\":\"mobilab-truck\"},\"dev_eui\":\"70B3D57ED0072D6C\",\"join_eui\":\"0000000000000000\",\"dev_addr\":\"260B7E4E\"},\"correlation_ids\":[\"gs:uplink:01K71FCN0MB0BA21P7D3NQ1TSW\"],\"received_at\":\"2025-10-08T08:35:47.556876883Z\",\"uplink_message\":{\"session_key_id\":\"AZl2rHHCAzLVJCH6gefqcg==\",\"f_port\":1,\"f_cnt\":18339,\"frm_payload\":\"AC4ANgHxABgAMiRO\",\"decoded_payload\":{\"LAST_WATER_LEAK_DURATION\":0,\"MOD\":2,\"WATER_LEAK_STATUS\":1,\"WATER_LEAK_TIMES\":0},\"rx_metadata\":[{\"gateway_ids\":{\"gateway_id\":\"lisah-ug65-1\",\"eui\":\"24E124FFFEF7E3D6\"},\"time\":\"2025-10-08T08:35:47.328Z\",\"timestamp\":403505293,\"rssi\":-82,\"channel_rssi\":-82,\"snr\":13.5,\"frequency_offset\":\"230\",\"location\":{\"latitude\":43.61944841808217,\"longitude\":3.857522711001851,\"altitude\":80,\"source\":\"SOURCE_REGISTRY\"},\"uplink_token\":\"ChoKGAoMbGlzYWgtdWc2NS0xEggk4ST//vfj1hCNgbTAARoMCOPEmMcGELDDl6YBIMjNqJbfkekGKgwI48SYxwYQgMSznAE=\",\"channel_index\":3,\"gps_time\":\"2025-10-08T08:35:47.328Z\",\"received_at\":\"2025-10-08T08:35:47.330007620Z\"}],\"settings\":{\"data_rate\":{\"lora\":{\"bandwidth\":125000,\"spreading_factor\":7,\"coding_rate\":\"4/5\"}},\"frequency\":\"867100000\",\"timestamp\":403505293,\"time\":\"2025-10-08T08:35:47.328Z\"},\"received_at\":\"2025-10-08T08:35:47.349656096Z\",\"consumed_airtime\":\"0.061696s\",\"packet_error_rate\":0.04761905,\"network_ids\":{\"net_id\":\"000013\",\"ns_id\":\"EC656E0000000181\",\"tenant_id\":\"ttn\",\"cluster_id\":\"eu1\",\"cluster_address\":\"eu1.cloud.thethings.network\"}}}",
        "payloadType": "json",
        "x": 110,
        "y": 560,
        "wires": [
            [
                "02586fa4c16be55a"
            ]
        ]
    },
    {
        "id": "e3cd9acf2a7f88e3",
        "type": "inject",
        "z": "02a9741c1b0f658d",
        "name": "lwl02 0",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"end_device_ids\":{\"device_id\":\"lwl02-01\",\"application_ids\":{\"application_id\":\"mobilab-truck\"},\"dev_eui\":\"70B3D57ED0072D6C\",\"join_eui\":\"0000000000000000\",\"dev_addr\":\"260B7E4E\"},\"correlation_ids\":[\"gs:uplink:01K71FCN0MB0BA21P7D3NQ1TSW\"],\"received_at\":\"2025-10-08T08:35:47.556876883Z\",\"uplink_message\":{\"session_key_id\":\"AZl2rHHCAzLVJCH6gefqcg==\",\"f_port\":1,\"f_cnt\":18339,\"frm_payload\":\"AC4ANgHxABgAMiRO\",\"decoded_payload\":{\"LAST_WATER_LEAK_DURATION\":0,\"MOD\":2,\"WATER_LEAK_STATUS\":0,\"WATER_LEAK_TIMES\":0},\"rx_metadata\":[{\"gateway_ids\":{\"gateway_id\":\"lisah-ug65-1\",\"eui\":\"24E124FFFEF7E3D6\"},\"time\":\"2025-10-08T08:35:47.328Z\",\"timestamp\":403505293,\"rssi\":-82,\"channel_rssi\":-82,\"snr\":13.5,\"frequency_offset\":\"230\",\"location\":{\"latitude\":43.61944841808217,\"longitude\":3.857522711001851,\"altitude\":80,\"source\":\"SOURCE_REGISTRY\"},\"uplink_token\":\"ChoKGAoMbGlzYWgtdWc2NS0xEggk4ST//vfj1hCNgbTAARoMCOPEmMcGELDDl6YBIMjNqJbfkekGKgwI48SYxwYQgMSznAE=\",\"channel_index\":3,\"gps_time\":\"2025-10-08T08:35:47.328Z\",\"received_at\":\"2025-10-08T08:35:47.330007620Z\"}],\"settings\":{\"data_rate\":{\"lora\":{\"bandwidth\":125000,\"spreading_factor\":7,\"coding_rate\":\"4/5\"}},\"frequency\":\"867100000\",\"timestamp\":403505293,\"time\":\"2025-10-08T08:35:47.328Z\"},\"received_at\":\"2025-10-08T08:35:47.349656096Z\",\"consumed_airtime\":\"0.061696s\",\"packet_error_rate\":0.04761905,\"network_ids\":{\"net_id\":\"000013\",\"ns_id\":\"EC656E0000000181\",\"tenant_id\":\"ttn\",\"cluster_id\":\"eu1\",\"cluster_address\":\"eu1.cloud.thethings.network\"}}}",
        "payloadType": "json",
        "x": 110,
        "y": 600,
        "wires": [
            [
                "02586fa4c16be55a"
            ]
        ]
    },
    {
        "id": "510519e47be0c93d",
        "type": "debug",
        "z": "02a9741c1b0f658d",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 320,
        "y": 320,
        "wires": []
    },
    {
        "id": "720a289596ba418a",
        "type": "inject",
        "z": "02a9741c1b0f658d",
        "name": "lht52-01",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"end_device_ids\":{\"device_id\":\"sonar-01\",\"application_ids\":{\"application_id\":\"chapitre\"},\"dev_eui\":\"70B3D57ED006570F\",\"join_eui\":\"A840410000000101\",\"dev_addr\":\"260BBFF4\"},\"correlation_ids\":[\"gs:uplink:01KABZAZ39S61FDZRSHEYJF8R7\"],\"received_at\":\"2025-11-18T17:13:59.351577212Z\",\"uplink_message\":{\"session_key_id\":\"AZm4bIMdB73gKSiYasLGeQ==\",\"f_port\":1,\"f_cnt\":28785,\"frm_payload\":\"UgAP\",\"decoded_payload\":{\"bytes\":[82,0,15]},\"rx_metadata\":[{\"gateway_ids\":{\"gateway_id\":\"eui-a84041ffff25542c\",\"eui\":\"A84041FFFF25542C\"},\"time\":\"2025-11-18T17:13:59.067949Z\",\"timestamp\":1953719129,\"rssi\":-91,\"channel_rssi\":-91,\"snr\":11,\"frequency_offset\":\"129\",\"uplink_token\":\"CiIKIAoUZXVpLWE4NDA0MWZmZmYyNTU0MmMSCKhAQf//JVQsENnGzaMHGgsI19LyyAYQmobHRCCop/CV7qgv\",\"channel_index\":2,\"received_at\":\"2025-11-18T17:13:57.949226017Z\"}],\"settings\":{\"data_rate\":{\"lora\":{\"bandwidth\":125000,\"spreading_factor\":7,\"coding_rate\":\"4/5\"}},\"frequency\":\"868500000\",\"timestamp\":1953719129,\"time\":\"2025-11-18T17:13:59.067949Z\"},\"received_at\":\"2025-11-18T17:13:59.145981768Z\",\"consumed_airtime\":\"0.051456s\",\"network_ids\":{\"net_id\":\"000013\",\"ns_id\":\"EC656E0000000181\",\"tenant_id\":\"ttn\",\"cluster_id\":\"eu1\",\"cluster_address\":\"eu1.cloud.thethings.network\"}}}",
        "payloadType": "json",
        "x": 120,
        "y": 640,
        "wires": [
            [
                "02586fa4c16be55a"
            ]
        ]
    },
    {
        "id": "b1e280fa47ce8145",
        "type": "switch",
        "z": "02a9741c1b0f658d",
        "name": "switch",
        "property": "ttnData.name",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "lds02",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "porte",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "lwl02",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "waterlow",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 14,
        "x": 430,
        "y": 940,
        "wires": [
            [
                "a335ad3d494610ad"
            ],
            [
                "a335ad3d494610ad"
            ],
            [
                "ed07deb163e5a14c"
            ],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            []
        ]
    },
    {
        "id": "a335ad3d494610ad",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "lds02",
        "func": "// --- Contexte global ---\nlet apps = flow.get(\"apps\", \"file\") || {};\n\n// --- Message entrant ---\nlet p = msg?.ttnData || {};\nlet deviceID = p.name;\nlet appID = p.app;\n\n// --- Vérifs minimales ---\nif (!appID || !deviceID) {\n    node.warn(\"Champs manquants (appID/deviceID)\");\n    return msg;\n}\n\nlet newSensor = {\n    name: deviceID,\n    appID: appID,\n    lastUpdate: p.lastUpdate,\n    rssi: p.rssi,\n    snr: p.snr,\n    battery: p.decoded_payload?.BAT_V,\n    value: p.decoded_payload?.DOOR_OPEN_STATUS\n};\n\n// --- Si l'application n'existe pas encore, on la crée ---\nif (!apps[appID]) {\n    apps[appID] = { chatID: \"000\", sensors: {} };\n}\n\n// --- Si le capteur n'existe pas encore, on le crée ---\nif (!apps[appID].sensors[deviceID]) {\n    apps[appID].sensors[deviceID] = newSensor;\n    flow.set(\"apps\", apps, \"file\");\n    msg.payload = { info: `${deviceID} créé dans ${appID}` };\n    return msg;\n}\n\n// --- Sinon, capteur existant ---\nlet storedSensor = apps[appID].sensors[deviceID];\nlet oldValue = storedSensor?.value ?? null;\n\n// --- Mise à jour de tous les champs sauf appID et name ---\nfor (let key of Object.keys(newSensor)) {\n    if (key !== \"appID\" && key !== \"name\") {\n        storedSensor[key] = newSensor[key];\n    }\n}\n// --- Sauvegarde ---\nflow.set(\"apps\", apps, \"file\");\n\n// --- Structure pour Postgre ---\nmsg.toStore = { [deviceID]: storedSensor};\n\n// --- Notification Telegram si changement de value ---\nif (oldValue !== null && oldValue !== newSensor.value && newSensor.value !== null) {\n    let chatID = Number(apps[appID].chatID);\n    if (chatID) {\n        msg.payload = {\n            chatId: chatID,\n            type: \"message\",\n            content: `${storedSensor.name} a changé d'état : ${oldValue} → ${newSensor.value}`\n        };\n        return msg; // vers le bot Telegram\n    }\n}\n\n// --- Sinon, passe le message Postgre ---\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 860,
        "wires": [
            []
        ]
    },
    {
        "id": "ed07deb163e5a14c",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "lwl02",
        "func": "// --- Contexte global ---\nlet apps = flow.get(\"apps\", \"file\") || {};\n\n// --- Message entrant ---\nlet p = msg?.ttnData || {};\nlet deviceID = p.name;\nlet appID = p.app;\n\n// --- Vérifs minimales ---\nif (!appID || !deviceID) {\n    node.warn(\"Champs manquants (appID/deviceID)\");\n    return msg;\n}\n\nlet newSensor = {\n    name: deviceID,\n    appID: appID,\n    lastUpdate: p.lastUpdate,\n    rssi: p.rssi,\n    snr: p.snr,\n    battery: p.decoded_payload?.BAT_V,\n    value: p.decoded_payload?.WATER_LEAK_STATUS\n};\n\n// --- Si l'application n'existe pas encore, on la crée ---\nif (!apps[appID]) {\n    apps[appID] = { chatID: \"000\", sensors: {} };\n}\n\n// --- Si le capteur n'existe pas encore, on le crée ---\nif (!apps[appID].sensors[deviceID]) {\n    apps[appID].sensors[deviceID] = newSensor;\n    flow.set(\"apps\", apps, \"file\");\n    msg.payload = { info: `${deviceID} créé dans ${appID}` };\n    return msg;\n}\n\n// --- Sinon, capteur existant ---\nlet storedSensor = apps[appID].sensors[deviceID];\nlet oldValue = storedSensor?.value ?? null;\n\n// --- Mise à jour de tous les champs sauf appID et name ---\nfor (let key of Object.keys(newSensor)) {\n    if (key !== \"appID\" && key !== \"name\") {\n        storedSensor[key] = newSensor[key];\n    }\n}\n// --- Sauvegarde ---\nflow.set(\"apps\", apps, \"file\");\n\n// --- Structure pour Postgre ---\nmsg.toStore = { [deviceID]: storedSensor};\n\n// --- Notification Telegram si changement de value ---\nif (oldValue !== null && oldValue !== newSensor.value && newSensor.value !== null) {\n    let chatID = Number(apps[appID].chatID);\n    if (chatID) {\n        msg.payload = {\n            chatId: chatID,\n            type: \"message\",\n            content: `${storedSensor.name} a changé d'état : ${oldValue} → ${newSensor.value}`\n        };\n        return msg; // vers le bot Telegram\n    }\n}\n\n// --- Sinon, passe le message Postgre ---\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 900,
        "wires": [
            []
        ]
    },
    {
        "id": "a47a5b8c138a7022",
        "type": "function",
        "z": "02a9741c1b0f658d",
        "name": "extractData",
        "func": "// Récupération du payload principal\nlet p = msg?.payload;\n\n// Vérifie la présence minimale d'un device ID\nif (!p.end_device_ids.device_id) {\n    node.warn(\"⚠️ Device ID manquant dans le message TTN\");\n    return null;\n}\n\n// Récupération du decoded_payload existant (TTN), sinon null\nlet decoded = p.uplink_message.decoded_payload ?? null;\n\n// Si pas de decoded_payload → on génère un fallback depuis frm_payload\nif (!decoded) {\n    const b64 = p.uplink_message.frm_payload;\n\n    if (!b64) {\n        node.warn(\"⚠️ Aucun decoded_payload et aucun frm_payload présent\");\n    } else {\n        const raw = Buffer.from(b64, \"base64\");\n        decoded = {\n            bytes: Array.from(raw),\n            length: raw.length,\n            hex: raw.toString(\"hex\")\n        };\n    }\n}\n\n// Récupère les métadonnées radio (si dispo)\nlet rx_metadata = p.uplink_message.rx_metadata || [];\n\n// Valeurs par défaut\nlet maxRSSI = rx_metadata?.[0]?.rssi ?? null;\nlet maxSNR  = rx_metadata?.[0]?.snr  ?? null;\n\n// Parcours pour trouver les valeurs maximales\nfor (let i = 1; i < (rx_metadata.length); i++) {\n    let m = rx_metadata[i];\n    if (m.rssi > maxRSSI) maxRSSI = m.rssi;\n    if (m.snr  > maxSNR)  maxSNR  = m.snr;\n}\n\n// Construit un message propre et résilient\nlet message = {\n    name: p.end_device_ids.device_id,\n    app: p.end_device_ids.application_ids.application_id,\n    lastUpdate: p.received_at,\n    rssi: maxRSSI,\n    snr: maxSNR,\n    decoded_payload: decoded\n};\n\n// Renvoie un message simplifié\nmsg.ttnData = message;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 210,
        "y": 820,
        "wires": [
            [
                "067cf5acc7346d1d"
            ]
        ]
    },
    {
        "id": "067cf5acc7346d1d",
        "type": "debug",
        "z": "02a9741c1b0f658d",
        "name": "debug 3",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 800,
        "wires": []
    },
    {
        "id": "return_200",
        "type": "http response",
        "z": "02a9741c1b0f658d",
        "name": "Return 200 to TTN",
        "statusCode": "200",
        "headers": {},
        "x": 390,
        "y": 400,
        "wires": []
    },
    {
        "id": "f0f91d3015d5a2b2",
        "type": "http in",
        "z": "02a9741c1b0f658d",
        "name": "Webhook TTN",
        "url": "/ttn/uplink",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 90,
        "y": 520,
        "wires": [
            [
                "02586fa4c16be55a",
                "510519e47be0c93d",
                "a47a5b8c138a7022",
                "return_200"
            ]
        ]
    },
    {
        "id": "4fc9bac5daa2d9d8",
        "type": "http request",
        "z": "02a9741c1b0f658d",
        "name": "testPostURL",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://nodered-mobilab.agrotic-dev.org/ttn/uplink",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 230,
        "y": 180,
        "wires": [
            [
                "9cdc860221fb27e6"
            ]
        ]
    },
    {
        "id": "9cdc860221fb27e6",
        "type": "debug",
        "z": "02a9741c1b0f658d",
        "name": "debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 370,
        "y": 180,
        "wires": []
    },
    {
        "id": "d52878ec273061cf",
        "type": "inject",
        "z": "02a9741c1b0f658d",
        "name": "inject",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 90,
        "y": 180,
        "wires": [
            [
                "4fc9bac5daa2d9d8"
            ]
        ]
    },
    {
        "id": "389caaaa5d0b8f80",
        "type": "telegram bot",
        "botname": "mobilab_bot",
        "usernames": "",
        "chatids": "",
        "baseapiurl": "",
        "testenvironment": false,
        "updatemode": "polling",
        "pollinterval": 300,
        "usesocks": false,
        "sockshost": "",
        "socksprotocol": "socks5",
        "socksport": 6667,
        "socksusername": "anonymous",
        "sockspassword": "",
        "bothost": "",
        "botpath": "",
        "localbothost": "0.0.0.0",
        "localbotport": 8443,
        "publicbotport": 8443,
        "privatekey": "",
        "certificate": "",
        "useselfsignedcertificate": false,
        "sslterminated": false,
        "verboselogging": false
    },
    {
        "id": "67e1b7606b84b9de",
        "type": "global-config",
        "env": [],
        "modules": {
            "node-red-contrib-telegrambot": "16.3.2"
        }
    }
]